<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>学习Python Doc第四天:数据结构</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="张朝龙" />
<link rel="stylesheet" type="text/css" href="../../css/worg.css" />
<a id="home" href="../../index.html"><img src="../../img/assets/home.png" ></a>
<a id="pdf"  href="./learning-python-day04.pdf"><img src="../../img/assets/pdf.png"></a>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">学习Python Doc第四天:数据结构</h1>
<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3f3f6f1">1. 深入了解 <code>list</code></a>
<ul>
<li><a href="#org8ca29fc">1.1. 把 <code>list</code> 当栈用</a></li>
<li><a href="#org30b590a">1.2. 把 <code>list</code> 当队列用</a></li>
<li><a href="#org7c1faf0">1.3. 队列推导式</a></li>
<li><a href="#org554e557">1.4. 嵌套的 <code>list</code> 推导式</a></li>
</ul>
</li>
<li><a href="#org9af1b98">2. <code>del</code> 语句</a></li>
<li><a href="#orgf0042b9">3. <code>tuple</code> 和 <code>sequence</code></a></li>
<li><a href="#org0296e95">4. <code>set</code></a></li>
<li><a href="#org22fe538">5. 字典（dictionaries）</a></li>
<li><a href="#org2a4e35f">6. 使用循环</a></li>
</ul>
</div>
</div>
<p>
<code>Python</code> 提供了丰富的数据结构，极大提高编码效率。今天，我们讨论与数据结构有关的知识点。
</p>

<div id="outline-container-org3f3f6f1" class="outline-2">
<h2 id="org3f3f6f1"><span class="section-number-2">1</span> 深入了解 <code>list</code></h2>
<div class="outline-text-2" id="text-1">
<p>

</p>

<p>
首先 <code>list</code> 数据类型提供了很多方法，我们把这些方法列举如下：
</p>
<div class="instance">
<ol class="org-ol">
<li><code>list.append(x)</code> 添加一个元素到列表的尾部，等效于 <i>a[len(a) :]=[x]</i> 注意等式右边的写法是 <code>[x]</code> 而不是 <code>x</code></li>
<li><code>list.extend(iterable)</code>  用 <code>iterable</code> 中的元素扩展 <code>list</code> ，等效于 <i>a[len(a) :] = iterable</i></li>
<li><code>list.insert(i,x)</code>  在指定位置添加新元素。第一个输入 <code>i</code> 是插入新元素的位置， 比如 <code>a.insert(0,x)</code> 是在 <code>list</code> 的第0个位置插入 <code>x</code> , <code>a.insert(len(a),x)</code> 等效于 <code>a.append(x)</code></li>
<li><code>list.remove(x)</code>  从 <code>list</code> 中移除第一个 <code>x</code> ,如果 <code>list</code> 中没有 <code>x</code> 则报错</li>
<li><code>list.pop([i])</code> 从 <code>list</code> 的指定位置删除元素，并返回这个元素。 如果没有给定具体位置，则弹出最后一个元素。注意 <code>[]</code> 表示这个函数参数是可选的。</li>
<li><code>list.index(x,[start],[end])</code> 返回第一个 <code>x</code> 的位置。 <code>start</code> 和 <code>end</code> 表示查找 <code>x</code> 的范围。</li>
<li><code>list.count(x)</code> 返回 <code>x</code> 在 <code>list</code> 中出现的次数</li>
<li><code>list.sort(key=None,reverse=False)</code> 对 <code>list</code> 中的元素进行排序</li>
<li><code>list.reverse()</code>  对  =list=　中的元素，逆序排序</li>
<li><code>list.copy</code> 返回一个 <code>list</code> 的副本</li>
</ol>

</div>
</div>
<div id="outline-container-org8ca29fc" class="outline-3">
<h3 id="org8ca29fc"><span class="section-number-3">1.1</span> 把 <code>list</code> 当栈用</h3>
<div class="outline-text-3" id="text-1-1">
<p>

</p>

<p>
<code>list</code> 结构以及其附带的方法，使得可以方便的把 <code>list</code> 当做栈（后进先出）用。看代码：
</p>
<pre class="example">
In [179]: stack = [3,4,5]

In [194]: stack.append(6)

In [198]: stack.append(7)

In [202]: stack
Out[210]: 
[3, 4, 5, 6, 7]

In [211]: stack.pop()
Out[215]: 
7

In [216]: stack
Out[220]: 
[3, 4, 5, 6]
</pre>
</div>
</div>
<div id="outline-container-org30b590a" class="outline-3">
<h3 id="org30b590a"><span class="section-number-3">1.2</span> 把 <code>list</code> 当队列用</h3>
<div class="outline-text-3" id="text-1-2">
<p>

</p>

<p>
同样，也可以使用 <code>list</code> 实现队列。对立的特点是先进先出，然而 <code>list</code> 对于这个操作并不是很高效，因为从 <code>list</code> 的尾部插入元素和弹出元素比较快，但是从 <code>list</code> 的头部插入或者弹出元素比较慢(因为所有的其他元素都要移位一次)。
</p>

<p>
为了实现队列，我们使用 <code>collections.deque</code> 。 <code>collections.deque</code> 的设计使得从队列的头部和尾部插入或者弹出元素都很方便。
</p>

<p>
看代码：
</p>
<pre class="example">
In [221]: from collections import deque

In [234]: queue = deque(['Eric','John','Michael'])

In [265]: queue.append('Terry')

In [282]: queue.append('Grahm')

In [298]: queue
Out[298]: 
deque(['Eric', 'John', 'Michael', 'Terry', 'Grahm'])

In [299]: queue.popleft()
Out[306]: 
'Eric'

In [307]: queue.popleft()
Out[313]: 
'John'
</pre>
</div>
</div>
<div id="outline-container-org7c1faf0" class="outline-3">
<h3 id="org7c1faf0"><span class="section-number-3">1.3</span> 队列推导式</h3>
<div class="outline-text-3" id="text-1-3">
<p>

</p>

<p>
队列推导式提供了一种简单的创建列表的方法。当我们需要把一些运算的结果作为队列元素时，队列推导式显得非常的方便。
</p>
<pre class="example">
squares = []
for x in range(10):
    squares.append(x**2)
</pre>

<p>
输出：
</p>
<pre class="example">
In [333]: squares
Out[337]: 
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</pre>
<p>
当然，我们可以使用更方便的方法创建上面的这个 <code>list</code> 
</p>

<pre class="example">
squares = list(map(lambda x:x**2,range(10)))
</pre>
<p>
或者
</p>
<pre class="example">
squares = [x**2 for x in range(10)]
</pre>

<p>
列表推导式由包含一个表达式的括号组成，表达式后面跟随一个 <code>for</code> 子句，之后可以有零或多个 <code>for</code> 或 <code>if</code> 子句。结果是一个列表，由表达式依据其后面的 <code>for</code> 和 <code>if</code> 子句上下文计算而来的结果构成。
</p>

<p>
比如
</p>
<pre class="example">
In [339]: [(x,y) for x in [1,2,3] for y in [3,1,4] if x!=y]
Out[397]: 
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
</pre>
<p>
上面的一行代码等效于：
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="linenr">1: </span><span style="color: #268bd2;">comp</span> = <span style="color: #2aa198;">[]</span>
<span class="linenr">2: </span><span style="color: #859900; font-weight: bold;">for</span> x <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #2aa198;">[</span><span style="color: #6c71c4;">1</span>,<span style="color: #6c71c4;">2</span>,<span style="color: #6c71c4;">3</span><span style="color: #2aa198;">]</span>:
<span class="linenr">3: </span>    <span style="color: #859900; font-weight: bold;">for</span> y <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #2aa198;">[</span><span style="color: #6c71c4;">3</span>,<span style="color: #6c71c4;">1</span>,<span style="color: #6c71c4;">4</span><span style="color: #2aa198;">]</span>:
<span class="linenr">4: </span>        <span style="color: #859900; font-weight: bold;">if</span> x != y:
<span class="linenr">5: </span>            comp.append<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>x,y<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
<p>
我们再给几个例子：
</p>
<pre class="example">
In [399]: vec = [-4,-2,0,2,4]

In [409]: [x*2 for x in vec]
Out[416]: 
[-8, -4, 0, 4, 8]

In [417]: [x for x in vec if x&gt;=0]
Out[444]: 
[0, 2, 4]

In [445]: [abs(x) for x in vec]
Out[456]: 
[4, 2, 0, 2, 4]

In [457]: freshfruit = [' banana',' loganberry','passion fruit ']

In [506]: [weapon.strip() for weapon in freshfruit]
Out[536]: 
['banana', 'loganberry', 'passion fruit']

In [537]: [(x,x**2) for x in range(6)]
Out[562]: 
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]

In [563]: [x,x**2 for x in range(6)]
  File "&lt;ipython-input-563-8d6940458683&gt;", line 1
    [x,x**2 for x in range(6)]
              ^
SyntaxError: invalid syntax


In [564]: vec = [[1,2,3],[4,5,6],[7,8,9]]

In [581]: [num for elem in vec for num in elem]
Out[596]: 
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>
<p>
从上面的例子，我们可以看到，如果生成的 <code>list</code> 中元素都是二元组的话，则必须用括号包起来。
</p>

<p>
<code>list</code> 生成器可以包括复杂的表达式或者嵌套函数
</p>

<pre class="example">
In [602]: [str(round(pi,i)) for i in range(1,6)]
Out[616]: 
['3.1', '3.14', '3.142', '3.1416', '3.14159']
</pre>
</div>
</div>
<div id="outline-container-org554e557" class="outline-3">
<h3 id="org554e557"><span class="section-number-3">1.4</span> 嵌套的 <code>list</code> 推导式</h3>
<div class="outline-text-3" id="text-1-4">
<p>

</p>

<p>
<code>list</code> 推导式的第一个表达式可以是任何表达式，包括 <code>list</code> 推导式。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #268bd2;">matrix</span> = <span style="color: #2aa198;">[</span>
    <span style="color: #b58900;">[</span><span style="color: #6c71c4;">1</span>,<span style="color: #6c71c4;">2</span>,<span style="color: #6c71c4;">3</span>,<span style="color: #6c71c4;">4</span><span style="color: #b58900;">]</span>,
    <span style="color: #b58900;">[</span><span style="color: #6c71c4;">5</span>,<span style="color: #6c71c4;">6</span>,<span style="color: #6c71c4;">7</span>,<span style="color: #6c71c4;">8</span><span style="color: #b58900;">]</span>,
    <span style="color: #b58900;">[</span><span style="color: #6c71c4;">9</span>,<span style="color: #6c71c4;">10</span>,<span style="color: #6c71c4;">11</span>,<span style="color: #6c71c4;">12</span><span style="color: #b58900;">]</span>,
<span style="color: #2aa198;">]</span>
<span style="color: #2aa198;">[</span><span style="color: #b58900;">[</span>row<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span> <span style="color: #859900; font-weight: bold;">for</span> row <span style="color: #859900; font-weight: bold;">in</span> matrix<span style="color: #b58900;">]</span> <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #b58900;">(</span><span style="color: #6c71c4;">4</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
</pre>
</div>
<p>
输出为：
</p>
<pre class="example">
In [619]: [[row[i] for row in matrix] for i in range(4)]
Out[658]: 
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</pre>
<p>
上面的代码实现了矩阵转置功能（交换了矩阵的行和列）。对于 <code>matrix</code> 这样的数据结构，
</p>
<pre class="example">
[x[0] for x in matrix]
</pre>
<p>
输出的是 <code>matrix</code> 的第 <code>0</code> 列 <code>[1,5,9]</code> 。
整个矩阵转换代码等效于：
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #268bd2;">matrix</span> = <span style="color: #2aa198;">[</span>
    <span style="color: #b58900;">[</span><span style="color: #6c71c4;">1</span>,<span style="color: #6c71c4;">2</span>,<span style="color: #6c71c4;">3</span>,<span style="color: #6c71c4;">4</span><span style="color: #b58900;">]</span>,
    <span style="color: #b58900;">[</span><span style="color: #6c71c4;">5</span>,<span style="color: #6c71c4;">6</span>,<span style="color: #6c71c4;">7</span>,<span style="color: #6c71c4;">8</span><span style="color: #b58900;">]</span>,
    <span style="color: #b58900;">[</span><span style="color: #6c71c4;">9</span>,<span style="color: #6c71c4;">10</span>,<span style="color: #6c71c4;">11</span>,<span style="color: #6c71c4;">12</span><span style="color: #b58900;">]</span>,
<span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">transpose</span> = <span style="color: #2aa198;">[]</span>
<span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #2aa198;">(</span><span style="color: #6c71c4;">4</span><span style="color: #2aa198;">)</span>:
    transpose.append<span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span>row<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span> <span style="color: #859900; font-weight: bold;">for</span> row <span style="color: #859900; font-weight: bold;">in</span> matrix<span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
</pre>
</div>
<p>
鉴于 <code>Python</code> 强大的函数库，这个转置功能可以通过 <code>zip</code> 来实现。
</p>
<pre class="example">
list(zip(*matrix))
</pre>
<p>
输出是：
</p>
<pre class="example">
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
</pre>
</div>
</div>
</div>
<div id="outline-container-org9af1b98" class="outline-2">
<h2 id="org9af1b98"><span class="section-number-2">2</span> <code>del</code> 语句</h2>
<div class="outline-text-2" id="text-2">
<p>

</p>

<p>
<code>list.remove(x)</code> 删除 <code>list</code> 中第一个值为 <code>x</code> 的元素。在移除的过程中必须给定 <code>x</code> 。  使用 <code>del</code> 语句可以不用给定 <code>x</code> 只用给定索引号就删除指定位置的元素。
</p>

<pre class="example">
In [736]: a = [1,2,3,4,5,6,7]

In [758]: del a[0]

In [770]: a
Out[770]: 
[2, 3, 4, 5, 6, 7]

In [771]: del a[5]

In [787]: a
Out[787]: 
[2, 3, 4, 5, 6]

In [788]: del a[2]

In [792]: a
Out[792]: 
[2, 3, 5, 6]
</pre>

<p>
<code>del</code> 也可以用来删除一个变量
</p>
<pre class="example">
del a
</pre>
</div>
</div>

<div id="outline-container-orgf0042b9" class="outline-2">
<h2 id="orgf0042b9"><span class="section-number-2">3</span> <code>tuple</code> 和 <code>sequence</code></h2>
<div class="outline-text-2" id="text-3">
<p>

</p>

<p>
<code>list</code> 和 <code>strings</code> 是两个 <code>sequence</code> 类型的数据类型。由于 <code>Python</code> 是一个不断演进的语言， <code>tuple</code> 是新加入的 <code>sequence</code> 成员。一个 <code>tuple</code> 的成员用逗号隔开，看例子：
</p>
<pre class="example">
In [793]: t = 12345, 54321, 'hello!'

In [821]: t[0]
Out[828]: 
12345

In [829]: t[2]
Out[832]: 
'hello!'

In [833]: t
Out[837]: 
(12345, 54321, 'hello!')

In [838]: u = t,(1,3,4)

In [854]: u
Out[854]: 
((12345, 54321, 'hello!'), (1, 3, 4))

In [855]: t[0]
Out[863]: 
12345

In [864]: t[0] = 8888
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-871-7f2f230bad03&gt; in &lt;module&gt;()
----&gt; 1 t[0] = 8888

TypeError: 'tuple' object does not support item assignment

In [872]: v = ([1,2,3],[4,5,6])

In [887]: v
Out[887]: 
([1, 2, 3], [4, 5, 6])
</pre>

<p>
从上面例子可以看出， <code>tuple</code> 的输出总是有括号包括。不可以给 <code>tuple</code> 中单个元素赋值。
</p>

<p>
尽管 <code>tuple</code> 和 <code>list</code> 有很多相似之处，但是他们经常在不同的场合使用。 <code>tuple</code> 是不可修改的。通常 <code>tuple</code> 包含不同种类的成员。 <code>list</code> 的成员则通常是相同类型的并可以通过迭代读写。
</p>

<p>
在创建另个或者一个元素的 <code>tuple</code> 时，有一些简单的技巧。
</p>
<pre class="example">
In [888]: empty = ()

In [903]: singleton = 'hello', # note the trailing comma

In [920]: len(empty)
Out[920]: 
0

In [921]: len(singleton)
Out[933]: 
1

In [934]: singleton
Out[942]: 
('hello',)
</pre>
</div>
</div>

<div id="outline-container-org0296e95" class="outline-2">
<h2 id="org0296e95"><span class="section-number-2">4</span> <code>set</code></h2>
<div class="outline-text-2" id="text-4">
<p>

</p>

<p>
<code>Python</code> 还有一个数据类型 <code>set</code> . 一个 <code>set</code> 是一组无重复元素的集合。 <code>set</code> 支持数学概念上的 <code>并</code> <code>交</code> <code>差</code> <code>对称差</code> . 通常用花括号和 <code>set()</code> 来创建 <code>set</code>
</p>

<pre class="example">
In [943]: basket = {'apple','orange','apple','pear','orange','banana'}

In [989]: print(basket)
{'banana', 'orange', 'pear', 'apple'}
</pre>
<p>
可以看出 <code>set</code> 自动删除集合中的重复元素。
</p>
<pre class="example">
In [997]: 'orange' in basket #fast membership testing
Out[1027]: 
True

In [1028]: 'crabgrass' in basket
Out[1052]: 
False
</pre>

<p>
可以快速的进行成员验证。
</p>

<pre class="example">
In [1053]: a = set('abracadabra')

In [1066]: b = set('alacazam')

In [1078]: a
Out[1078]: 
{'a', 'b', 'c', 'd', 'r'}

In [1079]: b
Out[1083]: 
{'a', 'c', 'l', 'm', 'z'}

In [1084]: a-b # letters in a but not in b
Out[1091]: 
{'b', 'd', 'r'}

In [1092]: a | b #letters in either a or b
Out[1099]: 
{'a', 'b', 'c', 'd', 'l', 'm', 'r', 'z'}

In [1100]: a + b #do not support +
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-1100-f96fb8f649b6&gt; in &lt;module&gt;()
----&gt; 1 a + b

TypeError: unsupported operand type(s) for +: 'set' and 'set'

In [1101]: a &amp; b #letter in both a and b
Out[1108]: 
{'a', 'c'}

In [1109]: a ^ b #letters in a or b nut not both
Out[1120]: 
{'b', 'd', 'l', 'm', 'r', 'z'}
</pre>

<p>
<code>Python</code> 除了支持列表推导式外，也支持集合推导式。
</p>
<pre class="example">
In [1121]: a = {x for x in 'abracadabra' if x not in 'abc'}

In [1146]: a
Out[1146]: 
{'d', 'r'}
</pre>
</div>
</div>

<div id="outline-container-org22fe538" class="outline-2">
<h2 id="org22fe538"><span class="section-number-2">5</span> 字典（dictionaries）</h2>
<div class="outline-text-2" id="text-5">
<p>

</p>

<p>
<code>dictionary</code> 是 <code>Python</code> 支持的又一数据类型，这个数据类型不是序列类型，而是映射类型(mapping types)。 序列类型（ <code>list</code> <code>tuple</code> <code>set</code> ）通过数字来索引元素， 映射类型的数据通过 关键字 (key)来索引元素。字符创和数字可以当做 <code>key</code> 来使用。如果 <code>tuple</code> 的成员都是 字符创，数字或者 <code>tuple</code> ，那么 <code>tuple</code> 也可以用来当做 <code>key</code> . 不能用 <code>list</code> 来当做 <code>key</code> ，因为 <code>list</code> 能够被修改。
</p>

<p>
通常，我们可以想象字典是一系列没有排序的 <code>key:value</code>  对，其中 <code>key</code> 在一个字典中是唯一的。 <code>{}</code> 创建空的字典。在字典中我们经常用的操作是按照某个 <code>key</code> 保存一个 <code>value</code> 或者，根据某个 <code>key</code> 读取 <code>value</code> 。同样，我们可以使用 <code>del</code> 来删除 <code>key:value</code> 。如果新存入的 <code>key</code> 和原来重复，那么原来的 <code>key</code> 对应的 <code>value</code> 就会被覆盖。如果试图从字典中读取某个不存在的 <code>key</code> 对应的 <code>value</code> 那么报错。
</p>

<p>
对一个字典执行 <code>list(d.keys())</code> 操作，返回这个字典使用的所有 <code>key</code> ,返回的 <code>list</code> 是无序的，如果你需要返回结果有序，那么使用 <code>sorted(d.keys())</code> . 使用 <code>in</code> 进行成员关系测试。看代码：
</p>
<pre class="example">
In [1147]: tel = {'jack':4098, 'sape':4139}

In [1186]: tel['guido'] = 4127

In [1198]: tel
Out[1198]: 
{'guido': 4127, 'jack': 4098, 'sape': 4139}

In [1199]: tel['jack']
Out[1211]: 
4098

In [1212]: del tel['sape']

In [1224]: tel['irv'] = 4127

In [1251]: tel
Out[1255]: 
{'guido': 4127, 'irv': 4127, 'jack': 4098}

In [1256]: list(tel.keys())
Out[1276]: 
['jack', 'irv', 'guido']

In [1277]: sorted(tel.keys())
Out[1284]: 
['guido', 'irv', 'jack']

In [1285]: 'guido' in tel
Out[1293]: 
True

In [1294]: 'jack' not in tel
Out[1300]: 
False
</pre>

<p>
可以使用 <code>dict()</code> 函数创建字典，看代码：
</p>
<pre class="example">
In [1301]: dict([('sape',4139),('guido',4127),('jack',4098)])
Out[1354]: 
{'guido': 4127, 'jack': 4098, 'sape': 4139}
</pre>

<p>
当然，字典也支持字典推导式，看代码：
</p>
<pre class="example">
In [1355]: {x:x**2 for x in (2,4,6)}
Out[1377]: 
{2: 4, 4: 16, 6: 36}
</pre>
<p>
当 <code>key</code> 是简单的字符创时，使用 <code>dict()</code> 来构建字典更容易，看代码：
</p>
<pre class="example">
In [1378]: dict(sape=4139,guido=4127,jack=4098)
Out[1433]: 
{'guido': 4127, 'jack': 4098, 'sape': 4139}
</pre>
</div>
</div>

<div id="outline-container-org2a4e35f" class="outline-2">
<h2 id="org2a4e35f"><span class="section-number-2">6</span> 使用循环</h2>
<div class="outline-text-2" id="text-6">
<p>

</p>

<p>
当在字典中使用循环的时候，可以使用 <code>item()</code> 来获取 <code>key:value</code> 。
</p>
<pre class="example">
knights = {'gallahad':'the pure','robin':'the brave'}
for k,v in knights.items():
    print(k,v)
</pre>

<p>
在我的环境中输出是：
</p>
<pre class="example">
In [1435]: robin the brave
gallahad the pure
</pre>
<p>
不知道为什么先输出了第二个 <code>key:value</code> ，难道输出是乱序的么？
</p>

<p>
当循环对象是序列类型的数据类型时，可以使用 <code>enumerate()</code> 来生成索引和该索引对应的值：
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">for</span> i,v <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">enumerate</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">[</span><span style="color: #2aa198;">'tic'</span>,<span style="color: #2aa198;">'tac'</span>,<span style="color: #2aa198;">'toe'</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>i,v<span style="color: #2aa198;">)</span>
</pre>
</div>
<p>
输出为：
</p>
<pre class="example">
In [1436]: 0 tic
1 tac
2 toe
</pre>

<p>
在两个或者多个序列（ <code>sequence</code> ） 中执行循环，可以使用 <code>zip()</code> 实现。
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #268bd2;">questions</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'name'</span>,<span style="color: #2aa198;">'quest'</span>,<span style="color: #2aa198;">'favorite color'</span><span style="color: #2aa198;">]</span>
<span style="color: #268bd2;">answers</span> = <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'lancelot'</span>,<span style="color: #2aa198;">'the holy grail'</span>,<span style="color: #2aa198;">'blue'</span><span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">for</span> q,a <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">zip</span><span style="color: #2aa198;">(</span>questions,answers<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">'what is your {0} It is {1}.'</span>.<span style="color: #839496; font-weight: bold;">format</span><span style="color: #b58900;">(</span>q,a<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div>
<p>
输出为：
</p>
<pre class="example">
In [1437]: what is your name It is lancelot.
what is your quest It is the holy grail.
what is your favorite color It is blue.
</pre>

<p>
其中 <code>list(zip(questions,answers))</code> 的结果是：
</p>
<pre class="example">
In [1438]: list(zip(questions,answers))
Out[1456]: 
[('name', 'lancelot'), ('quest', 'the holy grail'), ('favorite color', 'blue')]
</pre>
<p>
如果要对一个 <code>sequence</code> 类型的数据进行逆向循环时，使用 <code>reversed()</code> 函数。
</p>

<pre class="example">
for i in reversed(range(1,10,2)):
    print(i)
</pre>
<p>
输出是：
</p>
<pre class="example">
In [1457]: 9
7
5
3
1
</pre>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'zclspace';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>
</body>
</html>
