<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>基于贝叶斯估计的线性回归</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="emacsun" />
<link rel="stylesheet" type="text/css" href="../../css/worg.css" />
<a id="home" href="../../index.html"><img src="../../img/assets/home.png" ></a>
<a id="pdf"  href="./PRMLch3dot3-bayesian-linear-regression.pdf"><img src="../../img/assets/pdf.png"></a>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "3em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">基于贝叶斯估计的线性回归</h1>
<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org80b5441">1. 简介</a></li>
<li><a href="#org2bf401a">2. 参数分布</a>
<ul>
<li><a href="#orge217cbb">2.1. 共轭先验估计</a></li>
<li><a href="#org2d79178">2.2. 后验估计</a></li>
</ul>
</li>
<li><a href="#org6edd4c7">3. 一个例子</a></li>
<li><a href="#orge71189d">4. 后记</a></li>
</ul>
</div>
</div>

<div id="outline-container-org80b5441" class="outline-2">
<h2 id="org80b5441"><span class="section-number-2">1</span> 简介</h2>
<div class="outline-text-2" id="text-1">
<p>

</p>

<p>
在讨论基于最大似然函数优化的线性回归模型的时候，我们发现模型的复杂度受限于基函数的个数和训练数据集合的大小。通常，为了避免过度拟合（导致巨大的模型系数），我们采用的办法是向对数最大斯然函数加上一个正则项。所以，基于最大似然函数的优化关键在于选择正则项以及基函数的形式。
</p>

<p>
因此，基于最大似然函数的优化普遍存在模型选择问题。我们必须选择合适的模型以避免过高的复杂度。通常，直接优化似然函数的方法并不可取，这样会导致过度拟合。我们在之前的博文中讨论过使用多份独立的数据做模型选择，但是这样一增加了计算复杂度，二浪费了宝贵数据。在本文中，我们讨论基于贝叶斯的线性回归方案。
</p>
</div>
</div>

<div id="outline-container-org2bf401a" class="outline-2">
<h2 id="org2bf401a"><span class="section-number-2">2</span> 参数分布</h2>
<div class="outline-text-2" id="text-2">
<p>

</p>
</div>

<div id="outline-container-orge217cbb" class="outline-3">
<h3 id="orge217cbb"><span class="section-number-3">2.1</span> 共轭先验估计</h3>
<div class="outline-text-3" id="text-2-1">
<p>

</p>

<p>
通过引入参数\(\mathbf{w}\)的先验估计，我们讨论基于贝叶斯的线性回归方案。我们假设已经知道噪声的精度\(\beta\)是个常数。我们知道似然函数\(p(\mathbf{t}|\mathbf{w})\)关于\(\mathbf{w}\)的指数二次型函数。那么，其对应的共轭先验函数也一定是高斯分布的。
</p>
\begin{equation}
\label{eq:1}
p(\mathbf{w}) = \mathcal{N}(\mathbf{w}|\mathbf{m}_{0},\mathbf{S}_{0})
\end{equation}
<p>
这个共轭先验函数的均值是\(\mathbf{m}_{0}\)，协方差矩阵是\(\mathbf{S}_{0}\)。
</p>
</div>
</div>
<div id="outline-container-org2d79178" class="outline-3">
<h3 id="org2d79178"><span class="section-number-3">2.2</span> 后验估计</h3>
<div class="outline-text-3" id="text-2-2">
<p>

</p>

<p>
后验估计是先验估计和似然函数的乘积。由于共轭先验函数是高斯函数，后验估计也是高斯的。对于高斯后验估计我们有：
</p>
\begin{equation}
\label{eq:2}
p(\mathbf{w}|\mathbf{t}) = \mathcal{N}(\mathbf{w}|\mathbf{m}_{N},\mathbf{S}_{N})
\end{equation}
<p>
其中：
</p>
\begin{eqnarray}
\label{eq:4}
\mathbf{m}_{N}&=& \mathbf{S}_{N}(\mathbf{S}_{0}^{-1}\mathbf{m}_{0} + \beta \mathbf{\Phi}^{T} \mathbf{t}) \\
\mathbf{S}_{N}^{-1} &=& \mathbf{S}_{0}^{-1} + \beta \mathbf{\Phi}^{T}\mathbf{\Phi}
\end{eqnarray}

<p>
权重矢量的最大后验估计\(\mathbf{w}_{MAP}=\mathbf{m}_{N}\)。如果我们假定\(\mathbf{S}_{0} = \alpha \mathbf{I}, \alpha\to 0\)，均值\(\mathbf{m}_{N}\)就会收敛到最大似然解\(\mathbf{m}_{ML}\)。这个\(\mathbf{S}_{0} = \alpha \mathbf{I}\)这个假设意味着相互独立相同分布。如果\(N = 0\)，则后验估计就是先验估计，这表明没有收到任何数据，也就无所谓后验之说。另外，如果数据是串行到达的，那么，当前时刻的后验估计可以作为下一时刻数据的先验估计。注意，迭代的思想就有了。
</p>
</div>
</div>
</div>
<div id="outline-container-org6edd4c7" class="outline-2">
<h2 id="org6edd4c7"><span class="section-number-2">3</span> 一个例子</h2>
<div class="outline-text-2" id="text-3">
<p>

</p>

<p>
我们考虑这样一个先验分布：
</p>
\begin{equation}
\label{eq:5}
p(\mathbf{w}|\alpha) = \mathcal{N}(\mathbf{w}|\mathbf{0},\alpha^{-1}\mathbf{I})
\end{equation}
<p>
对应的后验分布如~(\ref{eq:2})所示，其中：
</p>
\begin{eqnarray}
\label{eq:7}
\mathbf{m}_{N}&=&\beta \mathbf{S}_{N}\mathbf{\Phi}^{T}\mathbf{t} \\
\mathbf{S}_{N}^{-1}&=& \alpha \mathbf{I} + \beta \mathbf{\Phi}^{T}\Phi
\end{eqnarray}
<p>
后验估计的对数形式是：
</p>
\begin{equation}
\label{eq:8}
\ln p(\mathbf{w}|\mathbf{t}) = -\frac{\beta}{2} \sum_{n=1}^{N} \{t_{n} - \mathbf{w}^{T}\mathbf{\phi}(\mathbf{x}_{n}) \}^{2} - \frac{\alpha}{2}\mathbf{w}^{T}\mathbf{w} + \mathrm{const}
\end{equation}

<p>
根据式~(\ref{eq:8})最大化\(\mathbf{w}\)等效于最小化加了正则项的平方和误差函数，其中正则项的系数为\(\frac{\alpha}{\beta}\)。
</p>

<p>
接下来，我们来描述一个线性基函数模型和迭代更新后验估计的过程。考虑单输入变量\(x\)，单目标变量\(t\)，以及模型\(y(x,\mathbf{w}) = w_{0} + w_{1}x\)。因为这个模型只有两个自适应参数，我们可以在\(\mathbf{w}\)域直接把先验函数和后验估计画出来。我们从\(f(x,\mathbf{a}) = a_{0} + a_{1}x,a_{0}=-0.3,a_{1}=0.5\)获得数据：首先从均匀分布\(U(x|-1,1)\)中获得随机的\(x\)，然后计算\(f(x,\mathbf{a})\)，最后加上一个标准差为\(0.2\)的高斯噪声。我们的目标是从最终受噪声污染的数据中，恢复\(a_{0},a_{1}\)。我们假定噪声方差是已知的。所以参数的精度为\(\beta = (1/0.2)^{2} = 25\)。同样我们设置\(\alpha = 2.0\)。
</p>

<p>
图 <a href="#orga8f77bf">1</a> 演示了当数据量越来越多时先验估计和后验估计迭代更新的过程。
</p>

<div id="orga8f77bf" class="figure">
<p><img src="../../img/computer_prml/20170812prioriandpost.png" alt="20170812prioriandpost.png" width="400" align="center" />
</p>
<p><span class="figure-number">图 1:</span> 先验估计和后验估计迭代更新的过程</p>
</div>

<p>
图  <a href="#orga8f77bf">1</a> 同时演示了当前的后验估计作为下一个数据到来时\(\mathbf{w}\)先验估计的过程。首先，第一行中间的图对应着还没有数据到达时\(\mathbf{w}\)域上的先验分布，最右边的图对应着随机取\(\mathbf{w}\)六次时\(y(\mathbf{w},x) = w_{0} + w_{1}x\)的图像。我们可以看到这个时候的图像完全是随机的，因为这个时候我们没有收到任何关于\(x\)的信息。
</p>

<p>
在第二行里，我们收到了一个数据点（第二行最右侧图里的蓝色圆圈）。第二行左手边的图是关于\(\mathbf{w}\)的先验估计\(p(t|x,\mathbf{w})\)。注意这个先验函数约束到所有的\(y(x,\mathbf{w}) = w_{0} + w_{1}x\)都必须经过或者几乎经过接收到的数据点（就是那个蓝色的圆圈）。我们把这个似然函数乘以第一行的先验估计，我们得到了第二行的后验估计。第二行最右边展示了第二行中间的后验估计\(\mathbf{w}\)采样点。我们可以看到这些\(y(\mathbf{w},x) = w_{0} + w_{1}x\)都几乎通过蓝色的数据点。
</p>

<p>
第三行展示了观测到第二个数据点后的效果。第三行的最左边展示了这个点的似然函数，第三行中间的图展示了这个似然函数与第二行得到的后验函数的乘积后获得的新的后验函数。这个后验函数是受两个数据点影响的函数。因为两个点决定一条直线，所以从这个后验分布上采样的\(\mathbf{w}\)可以比较完美的通过两个数据点（见第三行最右边的图）。
</p>

<p>
第四行展示了观测到 20 个数据后的效果。左手边的图展示了第 20 个数据点的似然函数，中间的图展示了基于所有 20 个数据点的后验估计。我们可以看到这个后验估计已经相当精确。当有无穷多个数据点到达时，这个后验估计就会变成一个\(\delta\)函数。
</p>
</div>
</div>
<div id="outline-container-orge71189d" class="outline-2">
<h2 id="orge71189d"><span class="section-number-2">4</span> 后记</h2>
<div class="outline-text-2" id="text-4">
<p>

</p>

<p>
这篇文章展示了使用贝叶斯方法不断逼近参数\(\mathbf{w}\)真实值的过程。在逼近过程中我们使用的先验函数是高斯的。当然，我们也可以使用其他的先验函数，比如：
</p>
\begin{equation}
\label{eq:9}
p(\mathbf{w}|\alpha) = \bigg[ \frac{q}{2} (\frac{\alpha}{2})^{1/q} \frac{1}{\Gamma(1/q)} \bigg]^{M}\exp\bigg( -\frac{\alpha}{2}\sum_{j=1}^{M}|w_{j}|^{q} \bigg)
\end{equation}
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'zclspace';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>
</body>
</html>
