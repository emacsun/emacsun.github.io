#+TITLE: Thinking in Java chapter 9 多态
#+AUTHOR:    emacsun
#+EMAIL:     emacsun@163.com
#+DATE:
#+DESCRIPTION:
#+KEYWORD
#+CATEGORIES:
#+SETUPFILE: ~/.emacs.d/org-templates/java-level2.org
#+HTML_HEAD_EXTRA: <a id="pdf"  href="./TIJ-ch09.pdf"><img src="../../img/assets/pdf.png"></a>
#+LaTeX_CLASS: cn-article

* 简介
  [2017-07-01 Sat 17:59]

继数据抽象（data abstraction）和继承( Inheritance )之后，多态(polymorphism)是 Java 语言支持的又一重要特性。

使用多态，可以针对同一个操作输入多种类型的数据。多态指的是同一操作支持多中数据类型。这在动态语言中显得尤为明显，比如 =Python= 。在 =Java= 中，我们也碰到过多态的例子，比如对于 =+= 如果我们 =1+2= 我们期待输出的结果是 =3= ，此时， =+= 的功能是数学里的加法运算，但是对于 ='a' + 'bc'= 这样的运算，我们希望输出的是 ='abc'= 也就是字符串的级联。这个小例子体现了 =+= 的多种形态。

多态往往和动态绑定等价。在很多地方 polymorphism 和 dynamic binding , late binding, runtime binding 相提并论。
* 重访 upcasting
  [2017-07-30 Sun 17:29]

我们知道通过继承，一个对象的类型可以是当前类（class），也可以是其父类。把一个对象的类型当作其父类来处理就叫做 upcasting. 但是通过下面的这个例子，我们就会看到 upcasting 会导致一个问题。

这是一个关于音乐的例子，由于多个类都要用到 Notes，比如 C 小调之类的专有名词，我们首先建立一个 =enum=

#+begin_src c -n
//: polymorphism/music/Note.java
// Notes to play on musical instruments.
package polymorphism.music;

public enum Note {
    MIDDLE_C, C_SHARP, B_FLAT; // Etc.
} ///:~
#+end_src

然后， =Wind= 是一个乐器 =Instrument= 。 =Wind= 类就继承自 =Instrument= 类。

=Instrument= 类：
#+begin_src c -n
//: polymorphism/music/Instrument.java
package polymorphism.music;
import static net.mindview.util.Print.*;

class Instrument {
  public void play(Note n) {
    print("Instrument.play()");
  }
}
 ///:~
#+end_src
=Wind= 类：
#+begin_src c -n
//: reusing/Wind.java
// Inheritance & upcasting.
package polymorphism.music;


// Wind objects are instruments
// because they have the same interface:
public class Wind extends Instrument {
  public void play(Note n){
   System.out.println("Wind.play" + n);
  }
} ///:~
#+end_src
最后是 =Music= 类：
#+begin_src c -n
//: polymorphism/music/Music.java
// Inheritance & upcasting.
package polymorphism.music;

public class Music {
  public static void tune(Instrument i) {
    // ...
    i.play(Note.MIDDLE_C);
  }
  public static void main(String[] args) {
    Wind flute = new Wind();
    tune(flute); // Upcasting
  }
} /* Output:
Wind.play() MIDDLE_C
*///:~
#+end_src
注意， =Music= 类的 =Music.tune=  方法接受了一个 =Instrument= 类型的对象。这说明任何从 =Instrument= 类继承下来的类的对象都可以送给 =Music.tune=. 在 =Music= 的 =main= 函数中，我们送给 =tune= 的就是 =Wind= 类型的对象。这是没有问题的，因为 =Wind= 类继承自 =Instrument= 类。在这里，通过给 =tune= 函数送入 =Instrument= 类型的对象，而不是 =Wind= 类型的对象，我们节约了大量的代码量。想象一下，乐器有好多种，也就是从 =Instrument= 类可以继承下来很多对象。如果我们为每一个乐器都写一个 =tune= 函数，这将是多么无聊的事情。

看如下无聊的代码：
#+begin_src c -n
//: polymorphism/music/Music2.java
// Overloading instead of upcasting.
package polymorphism.music;
import static net.mindview.util.Print.*;

class Stringed extends Instrument {
  public void play(Note n) {
    print("Stringed.play() " + n);
  }
}

class Brass extends Instrument {
  public void play(Note n) {
    print("Brass.play() " + n);
  }
}

public class Music2 {
  public static void tune(Wind i) {
    i.play(Note.MIDDLE_C);
  }
  public static void tune(Stringed i) {
    i.play(Note.MIDDLE_C);
  }
  public static void tune(Brass i) {
    i.play(Note.MIDDLE_C);
  }
  public static void main(String[] args) {
    Wind flute = new Wind();
    Stringed violin = new Stringed();
    Brass frenchHorn = new Brass();
    tune(flute); // No upcasting
    tune(violin);
    tune(frenchHorn);
  }
} /* Output:
Wind.play() MIDDLE_C
Stringed.play() MIDDLE_C
Brass.play() MIDDLE_C
*///:~
#+end_src
上面的代码可以工作，但是这个代码结构有一个致命的问题：你必须为每一个乐器编写 =tune= 函数。 那么，如果能够只写一次 =tune= 方法，且送入的对象是 =Instrument= 类型，而不是 =Instrument= 的任一子类，岂不是更好？也就是说，在使用 =tune= 方法的时候，我们如果忘记 =tune= 的参数类型岂不是更好？这就是多态带来的福利。
* 纠结
  [2017-07-30 Sun 18:03]

现在，我们有一个问题， =Java= 在编译的过程中怎么知道 =Instrument= 类指向的是 =Wind= 而不是 =Brass= 或者 =Stringed= 类？答案是：编译器不知道。为理解这个问题，我们探讨 =binding= 的原理。

** 方法调用 =binding=

把方法调用和方法本身连接起来的过程叫做 =binding= 。程序执行之前的 binding 叫做 early binding (可能由编译器和链接器来完成)。 =C= 语言种的 binding 都是 early binding。但是，我们前面的例子告诉我们 =Java= 中， =binding= 的方式有些不一样。因为编译器不知道到底该调用哪个方法。所以 =Java= 中的 binding 方法是所谓的 late binding .意味着 binding 发生在程序运行时。late binding 也叫做 dynamic binding 或者 runtime binding。

Java 中除了 =static= 和 =final= 方法外，所有的方法都是 *late binding* .这意味着，你不需要显示的为某个方法指示用什么 binding 方式。Java 已经帮你安排好了。所有的 =private= 方法都是 =final= 类型的。指定一个方法为 =final= 意味着，你不想这个方法动态绑定。这样做的一个好处是编译器会编译出更高效的代码。但是，你不能因为性能的借口，到处使用 =final= ,你应该处于设计的原因使用 =final= ，毕竟使用 =final= 带来的性能提升没有那么多。

** 正确的行为

一旦知晓 Java 的动态绑定，我们就可以写出支持多态的漂亮代码。你的代码针对的类型不只是当前类，当前类的父类，父类的父类的对象都可以作为参数。这在 =Python= 中也有明显的体现（Python 是完全动态的语言）。 我们使用一个经常用到的例子来阐述与 动态绑定相关的概念。
#+CAPTION:  动态绑定
#+ATTR_HTML:  :width 400 :align center
#+NAME: fig:20170730shape
#+ATTR_LATEX: :width 0.6\textwidth :align center
[[../../img/computer_TIJ/20170730shape.png]]

根据上图：
#+begin_src java
Shape s = new Circle();
#+end_src
这个语句生成了 =Circle= 对象，生成的结果转换成了 =Shape= 类型。貌似，这是一个错误，毕竟我们把一种类型的对象转换成了另一种类型。但是，这是可以的，因为 =Circle= 类继承自 =Shape= . 问题来了，
#+begin_src java
s.draw();
#+end_src
调用的是哪个函数？你可能会认为调用的是 =Shape= 的 =draw()= 函数，因为 =s= 被转换成了 =Shape= 类型。但是，这里调用的是 =Circle.draw()= . 为甚么？因为多态。

接下来，看代码，首先是 =Shape= 类：
#+begin_src java -n
//: polymorphism/shape/Shape.java
package polymorphism.shape;

public class Shape {
  public void draw() {}
  public void erase() {}
} ///:~
#+end_src
=Circle= 类：
#+begin_src java -n
//: polymorphism/shape/Circle.java
package polymorphism.shape;
import static net.mindview.util.Print.*;

public class Circle extends Shape {
  public void draw() { print("Circle.draw()"); }
  public void erase() { print("Circle.erase()"); }
} ///:~
#+end_src
=Square= 类：
#+begin_src java -n
//: polymorphism/shape/Square.java
package polymorphism.shape;
import static net.mindview.util.Print.*;

public class Square extends Shape {
  public void draw() { print("Square.draw()"); }
  public void erase() { print("Square.erase()"); }
} ///:~
#+end_src
=Triangle= 类：
#+begin_src java -n
//: polymorphism/shape/Triangle.java
package polymorphism.shape;
import static net.mindview.util.Print.*;

public class Triangle extends Shape {
  public void draw() { print("Triangle.draw()"); }
  public void erase() { print("Triangle.erase()"); }
} ///:~
#+end_src
随机生成形状类：
#+begin_src java -n
//: polymorphism/shape/RandomShapeGenerator.java
// A "factory" that randomly creates shapes.
package polymorphism.shape;
import java.util.*;

public class RandomShapeGenerator {
  private Random rand = new Random(47);
  public Shape next() {
    switch(rand.nextInt(3)) {
      default:
      case 0: return new Circle();
      case 1: return new Square();
      case 2: return new Triangle();
    }
  }
} ///:~
#+end_src
调用以上代码：
#+begin_src java -n
//: polymorphism/Shapes.java
// Polymorphism in Java.
import polymorphism.shape.*;

public class Shapes {
  private static RandomShapeGenerator gen =
    new RandomShapeGenerator();
  public static void main(String[] args) {
    Shape[] s = new Shape[9];
    // Fill up the array with shapes:
    for(int i = 0; i < s.length; i++)
      s[i] = gen.next();
    // Make polymorphic method calls:
    for(Shape shp : s)
      shp.draw();
  }
} /* Output:
Triangle.draw()
Triangle.draw()
Square.draw()
Triangle.draw()
Square.draw()
Triangle.draw()
Square.draw()
Triangle.draw()
Circle.draw()
*///:~
#+end_src
基类 =Shape= 构建了所有子类的函数接口：所有的子类都可以被 =draw= 和 =erase= 。 =RandomShapeGenerator= 是一个形状工厂，随机生成形状对象，并保存在 =s= 中。每一个类对象是 =Circle= =Square= 或者 =Triangle= 中的一个，但是在 =return= 的时候， =upcast= 成为 =Shape= 类对象。因此当调用 =next()= 时，返回的永远是 =Shape= 类对象。

=main()= 函数通过调用 =RandomShapeGenerator.next()= 生成了 9 个 =Shape= 类对象，保存在 =s= 中。在这个时候，你知道你有一个 =Shape= 的数组，但是你不知道，生成的到底时 =Circle= =Square= 还是 =Triangle= 。但是，当你逐个调用 =draw()= 函数的时候，奇妙的事情发生了， =Java= 居然可以知道每一个 =Shape= 该执行哪一个 =draw()= 这个就是多态。
** 可扩展性
   [2017-08-05 Sat 08:19]

现在我们重新考虑上面乐器的例子。如上所述，使用多态技术，我们可以在不改变 =tune()= 方法的前提下，添加任意多种乐器类型。在一个设计考究的面向对象系统中，许多方法都具有类似 =tune()= 的模式，这些子类只与基类通信，但是使用的却是各自的 =tune()= 实现。这种代码就由很强的可扩展性。因为通过继承基类的数据类型，我们可以添加新的功能。最重要的，我们不需要改变基类的实现，我们使用的仅仅是基类的接口，真正的实现在各个子类的方法中。

图 [[fig:20170805extensibility]]是一个扩展的例子。
#+CAPTION:  extensibility
#+ATTR_HTML:  :width 400 :align center
#+NAME: fig:20170805extensibility
#+ATTR_LATEX: :width 0.6\textwidth :align center
[[../../img/computer_TIJ/20170805extensibility.png]]

所有这些新类都和原来的 =tune()= 相安无事。即便我们把 =tune()= 放到一个分离的文件中，并为 =Instrument= 类上添加新的方法， =tune()= 依然会工作的很好（我们甚至不用重新编译这个文件）。

图 [[fig:20170805extensibility]] 所示的代码如下：
#+begin_src c -n
//: polymorphism/music3/Music3.java
// An extensible program.
package polymorphism.music3;
import polymorphism.music.Note;
import static net.mindview.util.Print.*;

class Instrument {
  void play(Note n) { print("Instrument.play() " + n); }
  String what() { return "Instrument"; }
  void adjust() { print("Adjusting Instrument"); }
}

class Wind extends Instrument {
  void play(Note n) { print("Wind.play() " + n); }
  String what() { return "Wind"; }
  void adjust() { print("Adjusting Wind"); }
}

class Percussion extends Instrument {
  void play(Note n) { print("Percussion.play() " + n); }
  String what() { return "Percussion"; }
  void adjust() { print("Adjusting Percussion"); }
}

class Stringed extends Instrument {
  void play(Note n) { print("Stringed.play() " + n); }
  String what() { return "Stringed"; }
  void adjust() { print("Adjusting Stringed"); }
}

class Brass extends Wind {
  void play(Note n) { print("Brass.play() " + n); }
  void adjust() { print("Adjusting Brass"); }
}

class Woodwind extends Wind {
  void play(Note n) { print("Woodwind.play() " + n); }
  String what() { return "Woodwind"; }
}

public class Music3 {
  // Doesn't care about type, so new types
  // added to the system still work right:
  public static void tune(Instrument i) {
    // ...
    i.play(Note.MIDDLE_C);
  }
  public static void tuneAll(Instrument[] e) {
    for(Instrument i : e)
      tune(i);
  }
  public static void main(String[] args) {
    // Upcasting during addition to the array:
    Instrument[] orchestra = {
      new Wind(),
      new Percussion(),
      new Stringed(),
      new Brass(),
      new Woodwind()
    };
    tuneAll(orchestra);
  }
} /* Output:
Wind.play() MIDDLE_C
Percussion.play() MIDDLE_C
Stringed.play() MIDDLE_C
Brass.play() MIDDLE_C
Woodwind.play() MIDDLE_C
*///:~
#+end_src
在上面的代码中，新添加了 =what()= ，该函数返回一个描述当前类的字符对象。另一个新添加的方法是 =adjust()= ，该方法提供了调节每一个乐器的方法。

在 =main()= 函数中，当在 =orchestra= 数组中放置一组乐器时，这些乐器自动升级为 =Instrument= 。

可以看到 =tune()= 函数完全忽略了其他代码的变化，依然和整个程序配合的很好。这就是多态带来的福利：只改变那些应该被改变的。
**  =private= 无法被覆盖
   [2017-08-05 Sat 08:55]

看下面代码：
#+begin_src c -n
//: polymorphism/PrivateOverride.java
// Trying to override a private method.
package polymorphism;
import static net.mindview.util.Print.*;

public class PrivateOverride {
  private void f() { print("private f()"); }
  public static void main(String[] args) {
    PrivateOverride po = new Derived();
    po.f();
  }
}

class Derived extends PrivateOverride {
  public void f() { print("public f()"); }
} /* Output:
private f()
*///:~
#+end_src
有可能，你会问：问什么输出不是 =public f()= ？这是 =private= 类型函数自带 =final= 标签，无法被覆盖。所以在 =Derived= 类中的函数是一个新函数。
** 对域的处理
   [2017-08-05 Sat 08:58]

   一旦你学了多态，就想处处使用多态。但是，只有普通函数支持多态。比如，如果你读取一个子域，这个过程是在编译阶段完成的。看代码：
#+begin_src c -n
//: polymorphism/FieldAccess.java
// Direct field access is determined at compile time.

class Super {
  public int field = 0;
  public int getField() { return field; }
}

class Sub extends Super {
  public int field = 1;
  public int getField() { return field; }
  public int getSuperField() { return super.field; }
}

public class FieldAccess {
  public static void main(String[] args) {
    Super sup = new Sub(); // Upcast
    System.out.println("sup.field = " + sup.field +
      ", sup.getField() = " + sup.getField());
    Sub sub = new Sub();
    System.out.println("sub.field = " +
      sub.field + ", sub.getField() = " +
      sub.getField() +
      ", sub.getSuperField() = " +
      sub.getSuperField());
  }
} /* Output:
sup.field = 0, sup.getField() = 1
sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0
*///:~
#+end_src
在上面的例子中，我们发现对于 =field= 的读取是在编译阶段完成的。但是对于函数 =getField= 的调用却是多态的。
** 对 =static= 方法的处理
   [2017-08-05 Sat 09:10]

   如果一个方法是 =static= 的，那么这个方法不具有多态属性。

看代码：
#+begin_src c -n
//: polymorphism/StaticPolymorphism.java
// Static methods are not polymorphic.

class StaticSuper {
  public static String staticGet() {
    return "Base staticGet()";
  }
  public String dynamicGet() {
    return "Base dynamicGet()";
  }
}

class StaticSub extends StaticSuper {
  public static String staticGet() {
    return "Derived staticGet()";
  }
  public String dynamicGet() {
    return "Derived dynamicGet()";
  }
}

public class StaticPolymorphism {
  public static void main(String[] args) {
    StaticSuper sup = new StaticSub(); // Upcast
    System.out.println(sup.staticGet());
    System.out.println(sup.dynamicGet());
  }
} /* Output:
Base staticGet()
Derived dynamicGet()
*///:~
#+end_src
我们可以看到， =static= 方法不具有多态属性，具有多态属性的是普通函数。
* 构造函数和多态
   [2017-08-05 Sat 09:16]

   构造函数和其他函数不一样，当构造函数和多态碰撞，其发生的化学反应更是不同。首先，构造函数不具有多态属性，因为构造函数是不带 =static= 的 =static= 函数。理解构造函数和多态的结合至关重要，可以帮助我们减少很多不必要的麻烦。
** 构造函数的调用顺序
  [2017-08-05 Sat 09:37]

  基类的构造函数总是在继承类的构造过程中被调用。如果有多级的继承关系，那么最上面的类的构造函数会被首先调用，依次类推。这样做的好处是保证类被正确的创建。由于 =private= 只能通过构造函数设置，所以保证构造函数的调用至关重要。

看代码：
#+begin_src c -n
//: polymorphism/Sandwich.java
// Order of constructor calls.
package polymorphism;
import static net.mindview.util.Print.*;

class Meal {
  Meal() { print("Meal()"); }
}

class Bread {
  Bread() { print("Bread()"); }
}

class Cheese {
  Cheese() { print("Cheese()"); }
}

class Lettuce {
  Lettuce() { print("Lettuce()"); }
}

class Lunch extends Meal {
  Lunch() { print("Lunch()"); }
}

class PortableLunch extends Lunch {
  PortableLunch() { print("PortableLunch()");}
}

public class Sandwich extends PortableLunch {
  private Bread b = new Bread();
  private Cheese c = new Cheese();
  private Lettuce l = new Lettuce();
  public Sandwich() { print("Sandwich()"); }
  public static void main(String[] args) {
    new Sandwich();
  }
} /* Output:
Meal()
Lunch()
PortableLunch()
Bread()
Cheese()
Lettuce()
Sandwich()
*///:~
#+end_src
在这个例子中，我们看到的层级关系是 =Meal->Lunch->PortableLunch->Sandwich= 。所以在创建 =Sandwich= 对象时，最先调用 =Meal= 的构造函数，然后是 =Lunch= , =PortableLunch= 接下来是类主体中的 =Bread= =Cheese= =Lettuce= 最后是 =main= 函数中的 =new Sandwich()= .

当有继承过程时，你需要清楚所有的基类，并且可以访问所有基类的带有 =public= 和 =protected= 的成员。
