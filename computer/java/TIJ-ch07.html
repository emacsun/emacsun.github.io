<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Thinking in Java chapter7 笔记和习题</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="emacsun" />
<link rel="stylesheet" type="text/css" href="../../css/worg.css"  />
<a id="home" href="../../index.html"><img src="../../img/assets/home.png" ></a>
<a id="pdf"  href="./TIJ-ch07.pdf"><img src="../../img/assets/pdf.png"></a>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Thinking in Java chapter7 笔记和习题</h1>
<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org21f06b0">1. <code>package</code> ：库的最小单元</a></li>
<li><a href="#orgee11ce4">2. 组织你的代码</a></li>
<li><a href="#org0053fe5">3. 创建独一无二的 <code>package</code> 名字</a></li>
<li><a href="#orgd8a32bd">4. <code>Java</code> 访问关键字</a>
<ul>
<li><a href="#orga829c26">4.1. <code>public</code></a></li>
<li><a href="#org0027d86">4.2. 默认的包</a></li>
<li><a href="#org7eba6b2">4.3. <code>private</code></a></li>
<li><a href="#org9d0e960">4.4. <code>protected</code></a></li>
</ul>
</li>
<li><a href="#org6021cf9">5. 总结</a></li>
</ul>
</div>
</div>
<p>
像 <code>Java</code> 这样的大型程序语言，每一次升级都牵涉甚广。语言的设计者希望修改语言的某些部分使其效率更高，而语言的使用者希望接口保持不变，从而保证之前的代码能够正常运行。这就产生了矛盾：语言设计者希望修改语言，语言使用者倾向于维持接口不变。于是，语言的设计者必须保证在修改了某些部分之后保持接口不变。对语言使用者来说，语言设计者的修改是透明的。
</p>

<p>
本章介绍 <code>Java</code> 是如何控制访问权限，从而达到 <code>Java</code> 在升级换代过程中维持函数接口不变的。按照访问权限从高到低排序， <code>Java</code> 提供了 <code>package</code> , <code>public</code> , <code>protected</code> ， <code>private</code> 这四个级别的访问控制。其中包访问规定了一组类是如何在一个库中打包的， <code>public</code> <code>protected</code> <code>private</code> 这三个关键词规定了类成员的访问方式。
</p>

<div id="outline-container-org21f06b0" class="outline-2">
<h2 id="org21f06b0"><span class="section-number-2">1</span> <code>package</code> ：库的最小单元</h2>
<div class="outline-text-2" id="text-1">
<p>

</p>

<p>
一个 <code>package</code> 包含了一组类，这些类在一个命名空间 ( <code>namespace</code> )下。 <code>Java</code> 语言本身内置了很多可用的库，比如 <code>utility</code> 库，这个库在命名空间 <code>java.util</code> 。 <code>java.util</code> 的一个类叫做 <code>ArrayList</code> ，那么我们如何才能使用 <code>ArrayList</code> 呢？ 一种可行的方法是使用全名 <code>java.util.ArrayList</code> ，看代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">//</span><span style="color: #586e75;">: access/FullQualification.java</span>
public <span style="color: #b58900;">class</span> <span style="color: #268bd2;">FullQualification</span> <span style="color: #2aa198;">{</span>
  public <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span><span style="color: #b58900;">(</span><span style="color: #b58900;">String</span><span style="color: #268bd2;">[]</span> args<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    java.util.ArrayList list = new java.util.ArrayList<span style="color: #268bd2;">()</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span> <span style="color: #586e75;">///</span><span style="color: #586e75;">:~</span>
</pre>
</div>

<p>
然而，使用全名的方法，一看就很烦，名字又臭又长。 <code>Java</code> 提供了一种简单的做法 <code>import</code> 。如果你想要 <code>import</code> 某个特定的类，可以使用 <code>import</code> 语句， 看代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">//</span><span style="color: #586e75;">: access/SingleImport.java</span>
<span style="color: #b58900;">import</span> <span style="color: #268bd2;">java</span>.util.ArrayList;
public <span style="color: #b58900;">class</span> <span style="color: #268bd2;">SingleImport</span> <span style="color: #2aa198;">{</span>
  public <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span><span style="color: #b58900;">(</span><span style="color: #b58900;">String</span><span style="color: #268bd2;">[]</span> args<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">ArrayList</span> <span style="color: #268bd2;">list</span> = new java.util.ArrayList<span style="color: #268bd2;">()</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span> <span style="color: #586e75;">///</span><span style="color: #586e75;">:~</span>
</pre>
</div>

<p>
现在开心了，因为使用 <code>ArrayList</code> 时，不用重复臭长的前缀。但是这样用一个类 <code>import</code> 一个类的方法也不是最有效的，尤其是当我们要用到 <code>java.util</code> 下的好多个类的时候。此时， <code>*</code> 是一个方便的符号，看：
</p>
<pre class="example">
import java.util.*
</pre>
<p>
这句话把所有的 <code>java.util</code> 下的类都导入了。
</p>

<p>
<code>import</code> 的做法提供了一种命名空间的管理机制。首先自定义类成员的名字是互相隔离的，比如 类 <code>A</code> 的方法 <code>f()</code> 和类 <code>B</code> 的方法 <code>f()</code> 不会造成冲突（即使他们有相同的签名） 。 那么是不是类成员的名字做到互相隔离就够了呢？不！假设你创建了一个 <code>Stack</code> 类，另外一个人也创建了一个类 <code>Stack</code> ，这个时候怎么办？ <code>Java</code> 为这种潜在的冲突提供了完整的解决方案。
</p>

<p>
截至目前我们都还没有碰到类名冲突的情况，那是因为我们的代码都很简单，当你要和别人一起合作完成较大的项目的时候，做好命名空间的保护是非常必要的。当你编写了一个 <code>Java</code> 文件，这个文件是一个基本的编译单元 ( <code>compilation unit</code> ，有时候也叫 <code>translation unit</code> ) 。每一个编译单元都以 <code>.java</code> 结尾。在这个编译单元中一定有一个 <code>public</code> 类，这个类名必须和文件名字一样(包括大小写！)。 <b>在一个编译单元中必须只有一个 <code>public</code> 类，否则的话，编译器会出警告或者报错</b> 如果在这个编译单元中有多个类，外界是不会知道的，因为他们不是 <code>public</code> 的。这些类为 <code>public</code> 的类提供支持，是幕后的螺丝钉。
</p>
</div>
</div>
<div id="outline-container-orgee11ce4" class="outline-2">
<h2 id="orgee11ce4"><span class="section-number-2">2</span> 组织你的代码</h2>
<div class="outline-text-2" id="text-2">
<p>

</p>

<p>
当你编译 <code>.java</code> 文件时，编译器会为这个文件中的每一个类创建一个文件，这个文件以 <code>.class</code> 结尾。因此编译结束后可能会有相当多的 <code>.class</code> 文件出现在文件夹下面。对于 <code>Java</code> 来说一个可执行的程序就是一堆 <code>.class</code> ，这些 <code>.class</code> 可以通过打包程序生成 <code>jar</code> 文件。在执行的过程中， <code>java</code>  解释器搜寻，装载，解释这些文件。
</p>

<p>
一个库( <code>library</code> )是一组类文件，每一个源文件包含一个 <code>public</code> 类和任何数量的非 <code>public</code> 类（再次强调，一个文件只有一个 <code>public</code> 类）。如果想要把所有的这些编译单元（也可以说是这些文件）组织在一起，说明他们是一伙的呢？ <code>package</code> 关键字就是做这个活的。
</p>

<p>
在编译单元（不知道我为什么非要称一个源文件为编译单元？好吧，在以后编译单元和一个源文件是等效的。）中使用 <code>package</code> 时，必须把 <code>package</code> 放置到文件的头部，也就是说除了注释意外的第一行。当你说:
</p>
<pre class="example">
package access;
</pre>
<p>
你在告诉编译器，你在告诉别的程序员：这个编译单元属于一个叫 <code>access</code> 的库。换句话说，这个编译单元的 <code>public</code> 类属于库 <code>access</code> 。这个类的名字被 <code>access</code> 罩着，任何人想要使用这个类都要使用全名或者 <code>import</code> 语句导入这个类，否则无法访问这个类。
</p>

<p>
举个例子，假设文件名是 <code>MyClass.java</code> 这意味着这个文件中一定有一个 <code>public</code> 类名字是  <code>MyClass</code> 。看代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">//</span><span style="color: #586e75;">: access/mypackage/MyClass.java</span>
<span style="color: #b58900;">package</span> <span style="color: #268bd2;">access</span>.mypackage;
public <span style="color: #b58900;">class</span> <span style="color: #268bd2;">MyClass</span> <span style="color: #2aa198;">{</span>
  <span style="color: #586e75;">// </span><span style="color: #586e75;">...</span>
<span style="color: #2aa198;">}</span> <span style="color: #586e75;">///</span><span style="color: #586e75;">:~</span>
</pre>
</div>
<p>
假若现在有人要用 <code>MyClass</code> 或者 <code>access</code> 中的其他类，他必须用 <code>import</code> 导入或者全名引用，从而使得 <code>access</code> 可以被访问到。
</p>


<p>
全名引用的做法如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">//</span><span style="color: #586e75;">: access/QualifiedMyClass.java</span>
public <span style="color: #b58900;">class</span> <span style="color: #268bd2;">QualifiedMyClass</span> <span style="color: #2aa198;">{</span>
  public <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span><span style="color: #b58900;">(</span><span style="color: #b58900;">String</span><span style="color: #268bd2;">[]</span> args<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    access.mypackage.MyClass m =
      new access.mypackage.MyClass<span style="color: #268bd2;">()</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span> <span style="color: #586e75;">///</span><span style="color: #586e75;">:~</span>
</pre>
</div>

<p>
使用 <code>import</code> 的做法如下：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">//</span><span style="color: #586e75;">: access/ImportedMyClass.java</span>
<span style="color: #b58900;">import</span> <span style="color: #268bd2;">access</span>.mypackage.*;
public <span style="color: #b58900;">class</span> <span style="color: #268bd2;">ImportedMyClass</span> <span style="color: #2aa198;">{</span>
  public <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span><span style="color: #b58900;">(</span><span style="color: #b58900;">String</span><span style="color: #268bd2;">[]</span> args<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">MyClass</span> <span style="color: #268bd2;">m</span> = new MyClass<span style="color: #268bd2;">()</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span> <span style="color: #586e75;">///</span><span style="color: #586e75;">:~</span>
</pre>
</div>

<p>
<code>package</code> 和 <code>import</code> 可以保证不管多少人在从事同一个 <code>Java</code> 项目都不会造成名字冲突。
</p>
</div>
</div>

<div id="outline-container-org0053fe5" class="outline-2">
<h2 id="org0053fe5"><span class="section-number-2">3</span> 创建独一无二的 <code>package</code> 名字</h2>
<div class="outline-text-2" id="text-3">
<p>

</p>

<p>
之前我们看到 <code>package</code> 是如何打包库的： 一个 <code>package</code> 不是把所有的文件合并成一个文件，相反，一个 <code>package</code> 可以由多个 <code>.class</code> 文件构成。那么这些 <code>.class</code> 如何组织？直观简单的做法是：把这些 <code>.class</code> 文件放到一个目录下，即使用操作系统提供的目录结构来组织 <code>.class</code> 文件。 <code>Java</code> 也使用这种方法。
</p>

<p>
把所有的 <code>package</code> 文件放到一个目录下解决了两个问题：1. 创建了唯一的 <code>package</code> 名字。通过这个目录的路径名字，我们可以找到该 <code>package</code> 的 <code>.class</code> 名字。通常， <code>package</code> 的第一部分是类创建者的域名逆序。由于域名是独一无二的，所以遵循这个规范写的类的名字也是独一无二的。2. 把所有类都保存到一个文件夹下，方便 <code>Java</code> 解释器寻找 <code>.class</code> 文件。
</p>


<p>
那么，是不是我们用了 <code>package</code> <code>import</code> 以及把类文件放到独一无二的文件路径中就不会有冲突了呢？不是的。假设两个库通过 <code>*</code> 导入，但是这两个库中有同名的类，这该怎么办？
</p>
<pre class="example">
import net.mindview.simple.*;
import java.util.*;
</pre>

<p>
<code>java.util*</code> 包含了类 <code>Vector</code> ，如果 <code>net.mindview.simple.*</code> 也包含了名为 <code>Vector</code> 的类，怎么办？
</p>
<pre class="example">
Vector v = new Vector();
</pre>

<p>
上面的一行代码到底调用的是哪里的 <code>Vector</code> 呢？解释器不知道，阅读代码的人也不知道。此时编译器会报错，强制写代码的人修改这个 <code>bug</code> 。如果你想使用 <code>java.util.*</code> 中的 <code>Vector</code> 你必须使用全名导入：
</p>
<pre class="example">
java.util.Vector v = new java.util.Vector();
</pre>

<p>
了解了 <code>package</code> 和 <code>import</code> 的用法之后，基本上可以编写自己的库了。
</p>
</div>
</div>


<div id="outline-container-orgd8a32bd" class="outline-2">
<h2 id="orgd8a32bd"><span class="section-number-2">4</span> <code>Java</code> 访问关键字</h2>
<div class="outline-text-2" id="text-4">
<p>

</p>

<p>
<code>java</code> 提供了 <code>public</code> <code>protected</code> 和 <code>private</code> 三个关键字用于控制对类的访问。这三个关键词控制了类中每一个成员的可访问程度，如果一个类的成员没有提供这三个关键字约束，那么这个成员的访问遵循 <code>package access</code> 也就是说，凡是能访问到这个类所属 <code>package</code> 的都可以访问到这个成员。 不过我们这里不准备再着墨 <code>package access</code> ，因为此前已有不少描述。 <code>public</code> <code>protected</code> 和 <code>private</code> 更值得关注。
</p>
</div>
<div id="outline-container-orga829c26" class="outline-3">
<h3 id="orga829c26"><span class="section-number-3">4.1</span> <code>public</code></h3>
<div class="outline-text-3" id="text-4-1">
<p>

</p>

<p>
<code>public</code> 意味着其后面的类成员可以被任何人访问。假设你定义了一个 <code>dessert</code> 类在 <code>Cookie.java</code> 这个编译单元中。看代码：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">//</span><span style="color: #586e75;">: access/dessert/Cookie.java</span>
<span style="color: #586e75;">// </span><span style="color: #586e75;">Creates a library.</span>
<span style="color: #b58900;">package</span> <span style="color: #268bd2;">access</span>.dessert;
public <span style="color: #b58900;">class</span> <span style="color: #268bd2;">Cookie</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">public</span> <span style="color: #268bd2;">Cookie</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    System.out.println<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Cookie constructor"</span><span style="color: #268bd2;">)</span>;
  <span style="color: #b58900;">}</span>
  <span style="color: #b58900;">void</span> <span style="color: #268bd2;">bite</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> System.out.println<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"bite"</span><span style="color: #268bd2;">)</span>; <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span> <span style="color: #586e75;">///</span><span style="color: #586e75;">:~</span>
</pre>
</div>
<p>
谨记： <code>Cookie.java</code> 生成的类文件必须在 <code>dessert</code> 的目录下，而 <code>dessert</code> 又必须在 <code>access</code> 所在的目录下，而 <code>access</code> 必须在 <code>CLASSPATH</code> 中包含的路径下。不要错误的默认 <code>Java</code> 会在当前路径下寻找 <code>.class</code> 。如果 <code>.</code> 不在 <code>CLASSPATH</code> 中，那么 <code>Java</code> 不会查看当前目录。现在，我们创建一个使用 <code>Cookie</code> 的程序：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">//</span><span style="color: #586e75;">: access/Dinner.java</span>
<span style="color: #586e75;">// </span><span style="color: #586e75;">Uses the library.</span>
<span style="color: #b58900;">import</span> <span style="color: #268bd2;">access</span>.dessert.*;
public <span style="color: #b58900;">class</span> <span style="color: #268bd2;">Dinner</span> <span style="color: #2aa198;">{</span>
  public <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span><span style="color: #b58900;">(</span><span style="color: #b58900;">String</span><span style="color: #268bd2;">[]</span> args<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">Cookie</span> <span style="color: #268bd2;">x</span> = new Cookie<span style="color: #268bd2;">()</span>;
    <span style="color: #586e75;">//</span><span style="color: #586e75;">! x.bite(); // Can&#8217;t access</span>
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span> <span style="color: #586e75;">/* </span><span style="color: #586e75;">Output:</span>
<span style="color: #586e75;">Cookie constructor</span>
<span style="color: #586e75;">*///</span><span style="color: #586e75;">:~</span>
</pre>
</div>

<p>
在代码中创建了一个 <code>Cookie</code> 的对象 <code>x</code> ，因为 <code>Cookie</code> 的构造函数是 <code>public</code> 的，这个类是 <code>public</code> 的。但是在 <code>Dinner.java</code> 中不能访问 <code>bite()</code> ,因为 <code>bite()</code> 只能有 <code>dessert</code> 访问（还记得 <code>package access</code> 么？）
</p>
</div>
</div>
<div id="outline-container-org0027d86" class="outline-3">
<h3 id="org0027d86"><span class="section-number-3">4.2</span> 默认的包</h3>
<div class="outline-text-3" id="text-4-2">
<p>

</p>

<p>
下面的代码能够编译通过：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">//</span><span style="color: #586e75;">: access/Cake.java</span>
<span style="color: #586e75;">// </span><span style="color: #586e75;">Accesses a class in a separate compilation unit.</span>
<span style="color: #b58900;">class</span> <span style="color: #268bd2;">Cake</span> <span style="color: #2aa198;">{</span>
  public <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span><span style="color: #b58900;">(</span><span style="color: #b58900;">String</span><span style="color: #268bd2;">[]</span> args<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #b58900;">Pie</span> <span style="color: #268bd2;">x</span> = new Pie<span style="color: #268bd2;">()</span>;
    x.f<span style="color: #268bd2;">()</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span> <span style="color: #586e75;">/* </span><span style="color: #586e75;">Output:</span>
<span style="color: #586e75;">Pie.f()</span>
<span style="color: #586e75;">*///</span><span style="color: #586e75;">:~</span>
</pre>
</div>

<p>
第二个文件是：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">//</span><span style="color: #586e75;">: access/Pie.java</span>
<span style="color: #586e75;">// </span><span style="color: #586e75;">The other class.</span>
<span style="color: #b58900;">class</span> <span style="color: #268bd2;">Pie</span> <span style="color: #2aa198;">{</span>
   <span style="color: #b58900;">void</span> <span style="color: #268bd2;">f</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span> System.out.println<span style="color: #268bd2;">(</span><span style="color: #2aa198;">"Pie.f()"</span><span style="color: #268bd2;">)</span>; <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span> <span style="color: #586e75;">///</span><span style="color: #586e75;">:~</span>
</pre>
</div>

<p>
你可能会以为这两个文件时完全独立的，但是 <code>Cake</code> 却能够创建 <code>Pie</code> 对象，并调用它的成员函数 <code>f()</code> 。他们之所以可以互相访问是因为他们在同一个文件夹中， <code>Java</code> 会把一个文件夹中的文件是做默认的包，因此在一个文件夹下的文件可以互相访问。
</p>
</div>
</div>
<div id="outline-container-org7eba6b2" class="outline-3">
<h3 id="org7eba6b2"><span class="section-number-3">4.3</span> <code>private</code></h3>
<div class="outline-text-3" id="text-4-3">
<p>

</p>

<p>
<code>private</code> 意味着除了这个类之外所有程序都不能访问该成员，包括在同一个 <code>package</code>  的其他类。貌似标记为 <code>private</code> 的类成员隔离了自己，但是细想，如果有很多人在创建同一个 <code>package</code> ，那么这个 <code>private</code> 就有意义了：只有你自己能访问，不用担心会影响到别人。
</p>

<p>
鉴于 <code>pakcage access</code> 已经提供了一定程度的隔离，你或许会认为 <code>private</code> 不那么重要。错！ <code>private</code> 非常重要，尤其在多线程场合（这个会在以后引入，现在只需要知道，该使用 <code>private</code> 的时候一定不要手软）。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #586e75;">//</span><span style="color: #586e75;">: access/IceCream.java</span>
<span style="color: #586e75;">// </span><span style="color: #586e75;">Demonstrates "private" keyword.</span>
<span style="color: #b58900;">class</span> <span style="color: #268bd2;">Sundae</span> <span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">private</span> <span style="color: #268bd2;">Sundae</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{}</span>
  <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">Sundae</span> <span style="color: #268bd2;">makeASundae</span><span style="color: #b58900;">()</span> <span style="color: #b58900;">{</span>
    <span style="color: #859900; font-weight: bold;">return</span> new Sundae<span style="color: #268bd2;">()</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span>
public <span style="color: #b58900;">class</span> <span style="color: #268bd2;">IceCream</span> <span style="color: #2aa198;">{</span>
  public <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span><span style="color: #b58900;">(</span><span style="color: #b58900;">String</span><span style="color: #268bd2;">[]</span> args<span style="color: #b58900;">)</span> <span style="color: #b58900;">{</span>
    <span style="color: #586e75;">//</span><span style="color: #586e75;">! Sundae x = new Sundae();</span>
    <span style="color: #b58900;">Sundae</span> <span style="color: #268bd2;">x</span> = Sundae.makeASundae<span style="color: #268bd2;">()</span>;
  <span style="color: #b58900;">}</span>
<span style="color: #2aa198;">}</span> <span style="color: #586e75;">///</span><span style="color: #586e75;">:~</span>
</pre>
</div>

<p>
上面代码给出了一个使用 <code>private</code> 的例子：有时候你可能想控制一个类的创造过程。在上面的例子中，不能通过 <code>Sundae()</code> 的构造函数来创造类（因为这个构造函数是 <code>private</code> ） ，只能实用 <code>makeASundae()</code> 来创造这个类。
</p>

<p>
关于 <code>private</code> 的实用有一个准则：任何你觉得是辅助性质的方法都可以标注为 <code>private</code> 。对于类中的数据成员也是如此，除非你要向别人展示类的内部实现，否则类的说有数据域都应该是 <code>private</code> 。
</p>
</div>
</div>
<div id="outline-container-org9d0e960" class="outline-3">
<h3 id="org9d0e960"><span class="section-number-3">4.4</span> <code>protected</code></h3>
<div class="outline-text-3" id="text-4-4">
<p>

</p>

<p>
理解 <code>protected</code> 这个关键词可能需要对 <b>继承</b> 有一点了解。但是为了完整性，这里简单的提一下，继承是根据已有类创建新类的过程。可以再已类的基础上添加新的成员，或者改变已有成员函数的行为。为了继承已有的类，你可以说新类扩展 (extends) 了基类。
</p>
<pre class="example">
class Foo extends Bar{}
</pre>

<p>
如果新类是基于已有类，那么你可以访问基类的 <code>public</code> 成员。（当然，如果在相同的 <code>package</code> 中，你还可以通过 <code>package access</code> 来访问一些成员 ） 。有时候基类创建者像创建一些只有基类能够访问的成员，而其他类不能访问。 <code>protected</code> 就是做这个活的。 <code>protected</code> 同样提供 <code>package access</code> 也就是说 <code>package</code> 中的其他类也能访问该类中的 <code>protected</code> 成员。
</p>
</div>
</div>
</div>
<div id="outline-container-org6021cf9" class="outline-2">
<h2 id="org6021cf9"><span class="section-number-2">5</span> 总结</h2>
<div class="outline-text-2" id="text-5">
<p>

</p>

<p>
本文简要叙述了 <code>java</code> 是如何提供访问控制的。主要包括 使用 <code>package</code> 和 <code>import</code> 来组织库，导入库。使用 <code>public</code> <code>protected</code> 和 <code>private</code> 来控制类成员的访问。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'zclspace';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>
</body>
</html>
