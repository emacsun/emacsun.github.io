<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>使用make编译多个文件</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="emacsun" />
<link rel="stylesheet" type="text/css" href="../../css/worg.css" />
<a id="home" href="../../index.html"><img src="../../img/assets/home.png" ></a>
<a id="pdf"  href="./compile-multiple-file-using-make.pdf"><img src="../../img/assets/pdf.png"></a>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">使用make编译多个文件</h1>
<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org82e5850">1. 引言</a></li>
<li><a href="#org44eec38">2. 九个文件的工程</a></li>
<li><a href="#orgf540e21">3. make</a></li>
<li><a href="#org1d9d416">4. 静态链接库</a></li>
</ul>
</div>
</div>

<div id="outline-container-org82e5850" class="outline-2">
<h2 id="org82e5850"><span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>

</p>

<p>
作为一名通信工程师，通常的C/C++代码都是只有一个文件，比如Turbo编码器或者译码器，LDPC编码器或者译码器。但是，偶尔也会用到需要编译多个文件的时候。我对庞大的Visual Studio又比较畏惧（主要是我那256G的硬盘比较畏惧），倾向于使用GCC。所以本文记录使用 <code>GCC</code> 和 <code>make</code> 编译多个文件。
</p>
</div>
</div>
<div id="outline-container-org44eec38" class="outline-2">
<h2 id="org44eec38"><span class="section-number-2">2</span> 九个文件的工程</h2>
<div class="outline-text-2" id="text-2">
<p>

</p>

<p>
首先给出有九个文件的工程，这九个文件分别是 <code>sum.c</code> <code>sum.h</code> <code>substract.c</code> <code>substract.h</code> <code>multiply.c</code> <code>multiply.h</code> <code>divide.c</code>  <code>divide.h</code>  <code>main.c</code> 其内容分别是实现浮点加减乘除。为节省篇幅，仅列出 <code>sum.h</code> 和 <code>sum.c</code> 。首先 <code>sum.h</code> ，这个文件只有一行，即 <code>sum()</code> 函数的声明。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900;">float</span> <span style="color: #268bd2;">sum</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">float</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">float</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">)</span>;
</pre>
</div>
<p>
然后是 <code>sum.c</code> ,这个文件实现了 <code>sum()</code> 函数。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"sum.h"</span>

<span style="color: #b58900;">float</span> <span style="color: #268bd2;">sum</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">float</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900;">float</span> <span style="color: #268bd2;">b</span><span style="color: #2aa198;">){</span>
  <span style="color: #859900; font-weight: bold;">return</span> a + b;
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
主文件 <code>main.c</code> 是：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">stdio.h</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">&lt;</span><span style="color: #2aa198;">math.h</span><span style="color: #2aa198;">&gt;</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"sum.h"</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"substract.h"</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"multiply.h"</span>
<span style="color: #268bd2;">#include</span> <span style="color: #2aa198;">"divide.h"</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
<span style="color: #2aa198;">{</span>
  <span style="color: #b58900;">float</span> <span style="color: #268bd2;">a</span>,<span style="color: #268bd2;">b</span>;
  a = <span style="color: #6c71c4;">3</span>;
  b = <span style="color: #6c71c4;">4</span>;
  printf<span style="color: #b58900;">(</span><span style="color: #2aa198;">"%f = %f + %f\n"</span>,sum<span style="color: #268bd2;">(</span>a,b<span style="color: #268bd2;">)</span>,a,b<span style="color: #b58900;">)</span>;
  printf<span style="color: #b58900;">(</span><span style="color: #2aa198;">"%f = %f - %f\n"</span>,substract<span style="color: #268bd2;">(</span>a,b<span style="color: #268bd2;">)</span>,a,b<span style="color: #b58900;">)</span>;
  printf<span style="color: #b58900;">(</span><span style="color: #2aa198;">"%f = %f * %f\n"</span>,multiply<span style="color: #268bd2;">(</span>a,b<span style="color: #268bd2;">)</span>,a,b<span style="color: #b58900;">)</span>;
  printf<span style="color: #b58900;">(</span><span style="color: #2aa198;">"%f = %f / %f\n"</span>,divide<span style="color: #268bd2;">(</span>a,b<span style="color: #268bd2;">)</span>,a,b<span style="color: #b58900;">)</span>;

  <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">0</span>;
<span style="color: #2aa198;">}</span>
</pre>
</div>
<p>
编译这九个文件的常规做法是逐个编译，或者使用：
</p>
<pre class="example">
gcc main.c sum.c substract.c multiply.c divide.c -o main
</pre>
<p>
但是这种做法的缺点是明显的：
</p>
<ol class="org-ol">
<li>随着文件的增多，编译工作将是一个工作量很大的无营养工作。</li>
<li>对于没有修改过的文件也要重新编译，无疑将增加编译时间</li>
</ol>
</div>
</div>
<div id="outline-container-orgf540e21" class="outline-2">
<h2 id="orgf540e21"><span class="section-number-2">3</span> make</h2>
<div class="outline-text-2" id="text-3">
<p>

</p>

<p>
我的make是跟着陈皓学的（陈皓是著名文档《跟我一起写Makefile》的作者。对于每个严肃的make学习者，这个文档都是极佳的入门资料。）
</p>

<p>
这个工程的makefile可以写为：
</p>
<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #268bd2;">main</span>: main.o sum.o substract.o multiply.o divide.o
  gcc main.o sum.o substract.o multiply.o divide.o -o main
<span style="color: #268bd2;">main.o</span>: main.c
  gcc -c main.c
<span style="color: #268bd2;">sum.o</span>: sum.c
  gcc -c sum.c
<span style="color: #268bd2;">substract.o</span>:substract.c
  gcc -c substract.c
<span style="color: #268bd2;">multiply.o</span>: multiply.c
  gcc -c multiply.c
<span style="color: #268bd2;">divide.o</span>: divide.c
  gcc -c divide.c
</pre>
</div>
<p>
make有很多特殊的变量，使用这些变量可以编写更加简洁的makefile。但是这些变量的使用，会使得不太熟悉makefile的人读起来费劲。对于只有九个文件的小工程，我倾向于使用这种最原始直观的makefile。即使这种最原始的makefile也极大的降低了编译工作量。
</p>
</div>
</div>
<div id="outline-container-org1d9d416" class="outline-2">
<h2 id="org1d9d416"><span class="section-number-2">4</span> 静态链接库</h2>
<div class="outline-text-2" id="text-4">
<p>

</p>

<p>
在实际工程中，我们希望把编好的程序打包变成库，供以后使用。windows和linux下都有两种打包后的程序：静态库和动态库。关于静态库和动态库，本文不做过多介绍。 这篇<a href="http://www.cnblogs.com/LittleHann/p/3980364.html"> 博文</a> 对C/C++ 跨平台交叉编译，静态库和动态库编译有比较详细的介绍。更详细的介绍见《程序员的自我修养：链接、装载与库》。
</p>

<p>
接下来，我演示如何在windows上使用gcc编译并使用静态库文件。静态库文件的编译非常简单，接着上面的工程：
</p>
<pre class="example">
gcc -c sum.c
</pre>
<p>
就会生成静态库文件 <code>sum.o</code> 。依次类推，生成 <code>substract.o</code> <code>multiply.o</code> <code>divide.o</code> ，然后使用 <code>ar</code> 把这些静态库打包：
</p>
<pre class="example">
ar rcs libmymath.a sum.o substract.o multiply.o divide.o
</pre>

<p>
编译 <code>main.c</code> 的时候就可以链接我们刚才生成的静态库，编译命令是：
</p>
<pre class="example">
gcc -o main main.c -L. -lmymath
</pre>

<p>
有两点需要注意：
</p>
<ol class="org-ol">
<li><code>-L.</code> 告诉GCC除了默认目录外当前目录也是搜索静态库的目录。</li>
<li><code>-lmymath</code> 告诉GCC链接的库的名字是 <code>mymath.a</code> .</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'zclspace';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>
</body>
</html>
