<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>递归问题：约瑟夫问题</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="emacsun" />
<meta  name="description" content="本文探讨《具体数学》第一章递归问题中的第三个问题：约瑟夫问题"
 />
<link rel="stylesheet" type="text/css" href="../../css/worg.css" />
<a id="home" href="../../index.html"><img src="../../img/assets/home.png" ></a>
<a id="part"  href="../index.html"><img src="../../img/assets/math2.png"></a>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "5em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">递归问题：约瑟夫问题</h1>
<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. 问题描述</a></li>
<li><a href="#orgheadline2">2. 约瑟夫问题递归式</a></li>
<li><a href="#orgheadline3">3. 约瑟夫递归式的解</a></li>
<li><a href="#orgheadline4">4. 拓展1:二进制与约瑟夫问题</a></li>
<li><a href="#orgheadline5">5. 拓展2:更一般的约瑟夫递归式</a></li>
<li><a href="#orgheadline6">6. 推广3:不同基底的约瑟夫递归式</a></li>
<li><a href="#orgheadline7">7. 推广4:倒数第二个位置</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> 问题描述</h2>
<div class="outline-text-2" id="text-1">
<p>

</p>

<p>
这是一个生死攸关的问题！至于如何生死攸关参见《具体数学》1.3节 The Josephus Problem。现在做如下简化：假设有 \(n\) 个人站成一圈，现在要每隔一个删除一个人，直到只有一个人幸存下来。例如 \(n=10\) 的情形如下：
</p>


<div class="figure">
<p><img src="../../img/josephus-10.jpg" alt="cat/spider image" align="center" width="400" />
</p>
<p><span class="figure-number">Figure 1:</span> n=10的约瑟夫问题</p>
</div>

<p>
消去的顺序是：2,4 6,8,10,3,7,1,9，于是5幸存下来。问题：确定幸存者的号码 \(J(n)\)？
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> 约瑟夫问题递归式</h2>
<div class="outline-text-2" id="text-2">
<p>

</p>

<p>
因为有 \(J(10)=5\)，所以我们猜测有 \(J(n)= \frac{n}{2}\)，但是一些简单的如同下表的例子否定了这个猜测。
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">\(n\)</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">6</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\({J_{n}}\)</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>


<p>
不过我们可以大胆猜测， \(J(n)\)一定是奇数，因为绕圈走一圈就消去了全部的偶数。如果 \(n\) 是偶数，则走一圈后除了仅剩下一半人口并且他们的号码有变化外，我们面临的情形是与刚开始相同的情形，如下图所示：
</p>

<div class="figure">
<p><img src="../../img/josephus-n-even.jpg" alt="cat/spider image" align="center" width="200" />
</p>
<p><span class="figure-number">Figure 2:</span> n为偶数时的约瑟夫问题</p>
</div>

<p>
如此，规模为 \(2n\) 问题就变成了规模为 \(n\) 的问题。这个规模为 \(n\) 的问题与原来相比只是在人员的序号上有所不同，具体说来就是除了每个人的号码加倍并减去1外， \(J(2n)\) 问题和 \(2J(n) -1\)问题没有什么区别。即
</p>
\begin{equation}
\label{eq:1}
J(2n) = 2J(n) -1 , n\ge 1
\end{equation}

<p>
由上文我们知道 \(J(10)=5\)，几乎瞬间我们就会知道 \(J(20)= 2J(10)-1= 2*5 -1 = 9\)。如此可以瞬间解决所有的 \(J(5*2^{m}),m\ge 1\)问题， \(J(5*2^{m}) = 2J(5*2^{m-1}) + 1 = 2*2^{m} +1 = 2^{m+1} +1\)，这一步隐含了数学归纳法的证明过程。
</p>

<p>
假设 \(n\) 是奇数，与偶数不同的情形在于，转第一圈后就把编号为1的人给杀掉了，第二圈开始是从编号为3的人开始的，第二圈开始后第一个要杀掉的人是5。
</p>


<div class="figure">
<p><img src="../../img/josephus-n-odd.jpg" alt="cat/spider image" align="center" width="200" />
</p>
<p><span class="figure-number">Figure 3:</span> n为奇数时的约瑟夫问题</p>
</div>

<p>
如此， \(J(2n+1)\)问题就简化为 \(2J(n)+1\)问题，即：
</p>
\begin{equation}
\label{eq:2}
J(2n+1) = 2J(n) +1 , n\ge 1
\end{equation}

<p>
综上，约瑟夫问题递归式可以总结为：
</p>

\begin{equation}
\label{eq:3}
\begin{split}
J(1)&=1 \\
J(2n)&=2J(n) -1 \\
J(2n+1)&=2J(n)+1
\end{split}
\end{equation}
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3"><span class="section-number-2">3</span> 约瑟夫递归式的解</h2>
<div class="outline-text-2" id="text-3">
<p>

</p>

<p>
从约瑟夫递归式可以看出，不同于汉诺塔和披萨饼问题，约瑟夫问题递归式给出的不是 \(J(n)\) 和 \(J(n-1)\) 之间的递归关系，而是 \(J(2n)\) 或者 \(J(2n-1)\) 与 \(J(n)\) 之间的关系。
</p>

<p>
有了递归式，我们计算一些较小的值
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">\(n\)</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-right">6</th>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-right">8</th>
<th scope="col" class="org-right">9</th>
<th scope="col" class="org-right">10</th>
<th scope="col" class="org-right">11</th>
<th scope="col" class="org-right">12</th>
<th scope="col" class="org-right">13</th>
<th scope="col" class="org-right">14</th>
<th scope="col" class="org-right">15</th>
<th scope="col" class="org-right">16</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(J_{n}\)</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">7</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">7</td>
<td class="org-right">9</td>
<td class="org-right">11</td>
<td class="org-right">13</td>
<td class="org-right">15</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>


<p>
显然，从上面的表格中可以看出，将 \(n\) 按照 2的幂次进行分组或许会出现一些转机。每一组开始的 \(J(n)\) 总是等于1。仔细观察上表，如果将 \(n\) 写作 \(2^{m}+l\)，则 \(J(n)=J(2^{m}+l) = 2l +1, m\ge 0\le l < 2^{m}\). 其中 \(2^{m}\)是不超过 \(n\) 的 \(2\)的最大幂，而 \(l=n-2^{m}\)。事实上，可以对 \(m\) 使用数学归纳法证明：
</p>
\begin{equation}
\label{eq:4}
J(n)=J(2^{m}+l) = 2l +1, m\ge 0\le l < 2^{m}
\end{equation}

<p>
如此，我们得出了约瑟夫问题的闭式解。对于 \(J(100)\) 因为 \(100=2^{6}+36\)，所以 \(J(100)=2*36 +1= 73\)
</p>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4"><span class="section-number-2">4</span> 拓展1:二进制与约瑟夫问题</h2>
<div class="outline-text-2" id="text-4">
<p>

</p>

<p>
接下来我们针对约瑟夫问题做一些深入的挖掘。在求解约瑟夫问题递归式闭式解的过程中， \(n\) 和 \(J(n)\) 的以2为基的表示发挥着重要的作用，我们自然要研究以2为基的表示与约瑟夫问题之间的关系。假设 \(n\) 的二进制表示为：
</p>
\begin{equation}
\label{eq:5}
n = (b_{m}b_{m-1}\ldots b_{1}b_{0})_{2}
\end{equation}
<p>
即， \(n = b_{m}2^{m} + b_{m-1}2^{m-1} + b_{1}2 + b_{0}\)，其中 \(b_{i}, i=0,1,\ldots,m-1\) 为 \(0\) 或者 \(1\)。  \(b_{m}=1\)，注意 \(n=2^{m}+l\)，所以：
</p>
\begin{eqnarray}
\label{eq:6}
n & = & (1b_{m-1}\ldots b_{1}b_{0})_{2} \\
l & = & (0b_{m-1}\ldots b_{1}b_{0})_{2} \\
2l& = & (b_{m-1}\ldots b_{1}b_{0}0)_{2} \\
2l+1& = & (b_{m-1}\ldots b_{1}b_{0}1)_{2} \\
J(n) & = & (b_{m-1}\ldots b_{1}b_{0}b_{m})_{2} 
\end{eqnarray}

<p>
即，我们得到了：
</p>
\begin{equation}
\label{eq:7}
J((b_{m}b_{m-1}\ldots b_{1}b_{0})_{2}) = (b_{m-1}b_{m-2}\ldots b_{1}b_{0}b_{m})_{2}
\end{equation}

<p>
在计算机程序设计过程中，只需要对 \(n\) 的二进制表示循环左移1位即可得到 \(J(n)\)!!!这是多么的令人激动啊！在刚开始的时候，我们看约瑟夫问题显得好困难，但是，此刻我们只需要对\(n\) 的二进制表示循环左移1位即可得到 \(J(n)\)!!! 对一个问题深入分析竟然可以得到如此精妙而简洁的答案！高老头不愧是高老头！
</p>

<p>
还以 \(J(100)\) 为例， 因为 \(100=(1100100)_{2}\)，所以 \(J((1100100)_{2}) = (1001001)_{2} = 73\) !!!
</p>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5"><span class="section-number-2">5</span> 拓展2:更一般的约瑟夫递归式</h2>
<div class="outline-text-2" id="text-5">
<p>

</p>

<p>
接下来跟进一步深入挖掘该问题，对约瑟夫递归式做更进一步的推广。如下：
</p>

\begin{equation}
\label{eq:8}
\begin{split}
 f(1) &= \alpha \\
 f(2n) &= 2f(n) + \beta \\
 f(2n+1) &= 2f(n) + \gamma
\end{split}
\end{equation}

<p>
可以看出在约瑟夫问题中， \(\alpha=1,\beta=-1,\gamma=1\)。接下来，我们依然从小入手，得出下表
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">n</th>
<th scope="col" class="org-left">\(f(n)\)</th>
</tr>

<tr>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-left">&alpha;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">2</td>
<td class="org-left">2&alpha;+&beta;</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">2&alpha;+  +&gamma;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">4</td>
<td class="org-left">4&alpha;+3&beta;</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">4&alpha;+2&beta;+&gamma;</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">4&alpha;+&beta;+2&gamma;</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">4&alpha;+  +3&gamma;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">8</td>
<td class="org-left">8&alpha;+7&beta;</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-left">8&alpha;+6&beta;+&gamma;</td>
</tr>
</tbody>
</table>

<p>
从上表我们可以看出， &alpha; 的系数是2的幂，且不超过n。 &beta; 的系数则从2的幂减一递减到0，&gamma; 的系数则从0开始递增直到2的幂减一。于是式(\ref{eq:1})的解可以表示为：
</p>
\begin{equation}
\label{eq:9}
f(n) = A(n) \alpha + B(n) \beta + C(n) \gamma
\end{equation}

<p>
则， \(A(n),B(n),C(n)\)可以分别表示为：
</p>
\begin{equation}
\label{eq:10}
\begin{split}
A(n) &= 2^{m} \\
B(n) & = 2^{m} -1 -l \\
C(n) & = l
\end{split}
\end{equation}

<p>
其中， \(n = 2^{m}+l, 0\le l < 2^{m},n\ge 1\). 对式(\ref{eq:9})用数学归纳法可以证明。
</p>

<p>
联想到之前采用二进制表示约瑟夫问题的解：
</p>
\begin{equation}
\label{eq:11}
J((b_{m}b_{m-1}\ldots b_{1}b_{0})_{2}) = (b_{m-1}b_{m-2}\ldots b_{1}b_{0}b_{m})_{2}
\end{equation}

<p>
\(n\) 的循环左移即是 \(J(n)\) 的解。那么对于式(\ref{eq:11}) 这个更一般的推广，有没有二进制表示呢？ 当然有！ 首先式（\ref{eq:11}） 可以改写为：
</p>
\begin{equation}
\label{eq:12}
\begin{split}
f(1) &=  \alpha \\
f(2n +j) &= 2f(n) +\beta_{j},  j=0,1
\end{split}
\end{equation}
<p>
则式(\ref{eq:12})可以改写为：
</p>

\begin{equation}
\label{eq:13}
\begin{split}
f((b_{m}b_{m-1}\ldots b_{1}b_{0})_{2}) &=  2f((b_{m}b_{m-1}\ldots b_{2}b_{1})_{2}) + \beta_{b_{0}} \\
&= 4f((b_{m}b_{m-1}\ldots b_{3}b_{2})_{2})+ 2\beta_{b_{1}} + \beta_{b_{0}} \\
&= 8f((b_{m}b_{m-1}\ldots b_{4}b_{3})_{2})+ 4\beta_{b_{2}} + 2\beta_{b_{1}} + \beta_{b_{0}} \\
& \vdots \\
&= 2^{m}f((b_{m})_{2}) + 2^{m-1}\beta_{b_{m-1}} + \ldots + 2\beta_{b_{1}} + \beta_{b_{0}} \\
&= 2^{m} \alpha + 2^{m-1}\beta_{b_{m-1}} + \ldots + 2\beta_{b_{1}} + \beta_{b_{0}} 
\end{split}
\end{equation}

<p>
最后，可得：
</p>
\begin{equation}
\label{eq:14}
f((b_{m}b_{m-1}\ldots b_{1}b_{0})_{2}) = (\alpha\beta_{b_{m-1}}\beta_{b_{m-2}}\ldots \beta_{b_{1}}\beta_{b_{0}})_{2}
\end{equation}

<p>
事实上我们对 \(f(n)\)的前几个解稍加整理即可看出式 (\ref{eq:14}) 的精妙。如下表
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">n</th>
<th scope="col" class="org-left">\(f(n)\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">&alpha;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">2</td>
<td class="org-left">2&alpha; +&beta;</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">2&alpha; +&gamma;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-right">4</td>
<td class="org-left">4&alpha; + 2&beta; + &beta;</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">4&alpha; + 2&beta; + &gamma;</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">4&alpha; + 2&gamma;+&beta;</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">4&alpha; + 2&gamma;+&gamma;</td>
</tr>
</tbody>
</table>

<p>
在此， 我们有 \(\beta_{0} = \beta , \beta_{1} = \gamma\). 仍然以 \(J(100)\) 为例，因为 \(100 = (1100100)_{2}\)， 其解为：
</p>

\begin{equation}
\label{eq:15}
(\alpha\beta_{b_{m-1}}\beta_{b_{m-2}}\ldots \beta_{b_{1}}\beta_{b_{0}})_{2} = ( 1 \beta_{1} \beta_{0}\beta_{0} \beta_{1}\beta_{0}\beta_{0})_{2} 
\end{equation} 

<p>
因为 \(\alpha = 1, \beta_{0}=\beta = -1, \beta_{1}=\gamma=1\) ，所以 式(\ref{eq:15})可以重写为：
</p>
\begin{equation}
\label{eq:16}
( 1 \beta_{1} \beta_{0}\beta_{0} \beta_{1}\beta_{0}\beta_{0})_{2} = (1\quad 1\quad -1\quad -1\quad 1\quad -1\quad -1)_{2} = 73
\end{equation}

<p>
注意在此，我们突破了二进制只有0和1的限制，不过这一突破使得约瑟夫的解更加的精炼。
</p>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6"><span class="section-number-2">6</span> 推广3:不同基底的约瑟夫递归式</h2>
<div class="outline-text-2" id="text-6">
<p>

</p>

<p>
可以沿着推广2的思路走的更远，我们对式(\ref{eq:12}) 做更进一步修改：
</p>
\begin{equation}
\label{eq:17}
\begin{split}
f(j) &=  \alpha_{j}, 1\le j < d \\
f(dn+j)&= c f(n) +\beta_{j}, 0\le j < d 
\end{split}
\end{equation}

<p>
式(\ref{eq:17})有变动基数的解：
</p>
\begin{equation}
\label{eq:18}
f((b_{m}b_{m-1}\ldots b_{1}b_{0})_{d}) = (\alpha_{b_{m}} \beta_{b_{m-1}} \beta_{b_{m-2}} \ldots \beta_{b_{1}} \beta_{b_{0}})_{c}
\end{equation}
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><span class="section-number-2">7</span> 推广4:倒数第二个位置</h2>
<div class="outline-text-2" id="text-7">
<p>

</p>

<p>
约瑟夫有一个朋友，他站在倒数第二个位置上因而获救。当每隔一个人就有一个人被处死时，倒数第二个幸存者 \(I(n)\) 的号码是多少？
</p>

<p>
每隔一个人就有一个人被处死的约瑟夫问题解为：
</p>

\begin{equation}
\label{eq:19}
J(n) = J(2^{m} +l) =  2l +1
\end{equation}

<p>
此时有： \(2l +1 = n-1 \rightarrow  n=2l +2\) ，满足此式的 \(n\) 总是倒数第二个位置上的人获救。\(a_{k}\)
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'emacsungithubio';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>
</body>
</html>
