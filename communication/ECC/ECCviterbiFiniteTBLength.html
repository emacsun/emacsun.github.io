<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>有限回溯长度的Viterbi译码器</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="zcl.space" />
<meta name="description" content="为了节约译码器内存，通常将译码器的回溯长度设定为约束长度的5倍左右。本文简单介绍回溯长度有限的Viterbi译码器及其性能"
 />
<meta name="keywords" content="communication viterbi ECC" />
<link rel="stylesheet" type="text/css" href="../../css/worg.css"  />
<a id="home" href="../../index.html"><img src="../../img/assets/home.png" ></a>
<a id="pdf"  href="./ECCviterbiFiniteTBLength.pdf"><img src="../../img/assets/pdf.png"></a>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "1em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "Neo-Euler"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "Neo-Euler"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">有限回溯长度的Viterbi译码器</h1>
<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdcc637a">1. 引言</a></li>
<li><a href="#org4d92293">2. Viterbi译码过程回顾</a></li>
<li><a href="#org0dca875">3. 有限回溯长度的Viterbi译码器</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdcc637a" class="outline-2">
<h2 id="orgdcc637a"><span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>

</p>

<p>
在《<a href="ECCviterbi.html">卷积编码和Viterbi译码</a>》 一文的最后一节，有两个问题，其中一个问：当卷积编码器的码块输入变得越来越长时，译码回溯长度也增大，为保存幸存路径所需要的内存随着回溯长度呈指数增长，怎么办？ 一个有效的解决办法是：限制回溯长度。实验证明，当Viterbi译码器的回溯长度为编码器约束长度的5倍时就不会带来性能的损失。本文对此做简单的验证分析。
</p>

<p>
本文的编码器与《<a href="ECCviterbi.html">卷积编码和Viterbi译码</a>》 一文中的编码器保持一致：约束长度为3，生成多项式为 \([7,5]_{8}\) ，码率为 \(1/2\)。编码结束时，本文依然对编码器做清零操作（上了厕所要记得冲，:), flushing the encoer）。对于带自动冲洗功能的卷积编码器，倘若输入二进制比特序列长度为 \(N\)，约束长度为 \(K\)，码率为 \(1/2\)则编码输出长度为 \(2N+ 2(K-1)\)，其中 \(2(K-1)\)个编码比特就是冲洗编码器产生的额外输出。
</p>
</div>
</div>
<div id="outline-container-org4d92293" class="outline-2">
<h2 id="org4d92293"><span class="section-number-2">2</span> Viterbi译码过程回顾</h2>
<div class="outline-text-2" id="text-2">
<p>

</p>

<p>
在介绍有限回溯长度的Viterbi译码器之前，我们先简要回顾Viterbi译码过程，分四步：
</p>

<ol class="org-ol">
<li>在接收端，一次输入两个接收比特给译码器。这两个比特可能是星座图判决的硬输出（硬比特），也可能是星座图判决的软输出（软比特）。针对这两个接收比特，计算汉明距离（应比特）或者欧式距离（软比特）。</li>
<li>对于篱笆图中的四个状态，计算路径度量（path metric）。在计算这四个状态的路径度量时，每一个状态都有两个父状态（即，可以从两个状态到达当前状态）。对于每一个可能条状态跳转，计算其路径度量，加上之前的路径度量，得到当前路径的度量。然后，选择一条较小路径度量的路径作为幸存路径。这就是Viterbi译码过程中的加比选过程。</li>
<li>保存当前状态幸存路径上的前一个状态。</li>
<li>当处理\(2N+ 2(K-1)\)个比特之后，我们知道卷积编码器的状态是00（这就是在编码的时候对编码器进行清零的好处）。我们就从00状态开始回溯。我们在第2步和第3步已经保存了所有幸存路径的前后状态。根据前后状态的改变，我们很容易就得到输入比特。这些输入比特就是Viterbi译码输出。</li>
</ol>

<p>
在进行第4步时，我们需要 \(2^{K-1}\times (N+k-1)\)个内存单元保存幸存状态矩阵。 <b>当 \(N\)变得很大时</b> ，需要大量的内存，实在不符合低复杂度接收机的原则。有没有办法降低Viterbi译码器对内存的需求，同时保证译码器性能不降低？答案是：有。
</p>
</div>
</div>

<div id="outline-container-org0dca875" class="outline-2">
<h2 id="org0dca875"><span class="section-number-2">3</span> 有限回溯长度的Viterbi译码器</h2>
<div class="outline-text-2" id="text-3">
<p>

</p>

<p>
通常，我把有限回溯长度的Viterbi译码器叫做“两步一回头”译码器。两步的大小分别是译码长度和纯粹回溯长度，一回头是指走完两步后就回溯译码。现在，你可能还不是很明白到底什么是“两步一回头”。看图<a href="#org5b37e32">1</a>
</p>


<div id="org5b37e32" class="figure">
<p><img src="../../img/20160117ViterbiFiniteTracebackLength.jpg" alt="20160117ViterbiFiniteTracebackLength.jpg" width="500" align="center" />
</p>
<p><span class="figure-number">图 1:</span> “两步一回头”有限回溯长度的Viterbi译码器</p>
</div>

<p>
在图<a href="#org5b37e32">1</a>中，总长为 \(N+K-1\)长的篱笆图倍分成多段，每段长度为 \(D+TB\), 在译码过程中，每处理 \(2*(D+TB)\) 长度的接收比特(对应长度为  \(D+TB\) 的信息比特，记住我们的卷积编码码率为1/2.) 回溯 \(TB\)长度，然后开始译码，译码长度为 \(D\)。依次类推，直到译出长度为 \(N+K-1\)的信息序列。整个过程可以总结为：
</p>

<ol class="org-ol">
<li>在 \(D+TB\) 时刻，开始回溯。在当前的幸存路径上回溯 \(TB\)次之后，开始译码，译码长度为 \(D\)。</li>
<li>在 \(2D+TB\) 时刻，再次开始回溯。在当前的幸存路径上回溯 \(TB\)次之后，开始译码，译码长度为 \(D\)。</li>
<li>依次类推，直到 \(N+K-1\)，我们知道篱笆图的最终状态为00，再次回溯译码。</li>
</ol>

<p>
注意在每\(D+TB\) 的幸存路径加比选过程中，都执行Viterbi算法。在图<a href="#org5b37e32">1</a>所示的译码算法过程中，只需要 \(D+2TB\)内存。另外，回溯过程中，初始状态的选择也很关键，通常有两种选择：
</p>

<ol class="org-ol">
<li>总是从一个固定状态回溯（比如固定从00状态）。</li>
<li>从最小度量的状态开始。</li>
</ol>

<p>
实验表明，无论从那种状态回溯，当回溯长度大于5倍的约束长度时，性能无差别。对于本文的译码器，回溯长度为15已经看不出有什么区别。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'zclspace';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>
</body>
</html>
