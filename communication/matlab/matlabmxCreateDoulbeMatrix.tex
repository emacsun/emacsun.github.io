\documentclass[10pt,a4paper,UTF8]{article}
\usepackage{zclorg}
\author{zcl.space}
\date{}
\title{Matlab与C混合编程API之mxCreateDoubleMatrix}
\hypersetup{
 pdfauthor={zcl.space},
 pdftitle={Matlab与C混合编程API之mxCreateDoubleMatrix},
 pdfkeywords={matlab communication simulation C},
 pdfsubject={mxCreateDoubleMatrix创建二维双精度浮点数组},
 pdfcreator={Emacs 25.0.50.1 (Org mode 8.3.2)}, 
 pdflang={English}}
\begin{document}

\maketitle\xiaosihao
\tableofcontents\newpage\newpage


\section{引言}
\label{sec:orgheadline1}


通过\href{matlabandc.org}{matlab与C混合编程之基本原理}, 我们知道，在matlab与C的混合编程中，桥梁函数 \texttt{mexFunction} 发挥着至关重要的作用。在这个桥梁函数中，通过调用matlab提供的API可以很方便的实现matlab和C之间的混合编程。本节介绍一个API，名称为： \texttt{mxCreateDoubleMatrix} 。该API的作用是创建二维的双精度浮点数组。

\section{调用语法}
\label{sec:orgheadline2}


在C文件中，调用 \texttt{mxCreateDoubleMatrix} 的语法为：
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include "matrix.h"
mxArray *mxCreateDoubleMatrix(mwSize m, mwSize n,
  mxComplexity ComplexFlag);
\end{lstlisting}

\section{输入输出参数}
\label{sec:orgheadline3}


输入参数如表\ref{tab:orgtable1}所示
\begin{table}[htb]
\caption{\label{tab:orgtable1}
mxCreateDoubleMatrix输入输出参数表}
\centering
\begin{tabular}{llll}
\hline
参数 & 性质 & 描述 & 类型\\
\hline
\texttt{m} & 输入 & 矩阵行数 & \texttt{mwSize}\\
\texttt{n} & 输入 & 矩阵列数 & \texttt{mwSize}\\
\texttt{ComplexFlag} & 输入 & 是否包含复数元素 & \texttt{ComplexFlag}\\
\hline
\end{tabular}
\end{table}

\texttt{mwSize} 是matlab自己定义的用于表示矩阵大小的类型。在C语言中，使用 \texttt{int} 也可以。但是 \texttt{mwSize} 具有跨平台的特性。默认情况下， \texttt{mwSize} 和 C中的 \texttt{int} 是等价的。 当使用 \texttt{mex -largeArrayDims} 编译选项的时候， \texttt{mwSize} 与C中的 \texttt{size\_t} 等价。 \texttt{mxComplexity} 用来指定矩阵中数值元素是否包含虚部（即，元素是否既有实部又有虚部）。 \texttt{mxComplexity} 的值只有两个 \texttt{mxREAL} 和 \texttt{mxComCOMPLEXITY} ，前者表示矩阵中元素有虚部，后者表示矩阵中元素没有虚部。之所以存在这样的类型，是因为matlab向C传送数值矩阵的时候，实部和虚部是分开完成的。


如果成功创建矩阵，则该函数的输出（即返回值）是一个指向 \texttt{mxArray} 类型的指针。否则返回NULL.
\section{功能描述}
\label{sec:orgheadline4}


该函数创建一个 \texttt{m} 行 \texttt{n} 列的矩阵，矩阵中的元素类型依 \texttt{mxComplexity} 的值而定。如果 \texttt{mxComplexity} 的值是 \texttt{mxREAL} 则矩阵中的元素类型全是实数，matlab会分配足够的空间来存放这些实数，并将这些实数初始化为0。如果 \texttt{mxComplexity} 的值是 \texttt{mxCOMPLEX} ，则matlab分配足够的空间来存放这个复数空间（实部地址为 \texttt{pr} ,虚部地址为 \texttt{pi} ），实部和虚部都初始化为0。

通过调用 \texttt{mxDestroyArray} 来释放 \texttt{mxCreateDoubleMatrix} 创建的矩阵占用的内存空间。

\section{一个例子}
\label{sec:orgheadline5}


举一个很简单的例子，写一个函数返回一个实数乘以2的值。这个例子很简单，但是包含了matlab到C之间互传数据的过程。
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=left}
\begin{lstlisting}
#include "mex.h"
void timestwo(double y[], double x[])
{
  y[0] = 2.0*x[0];
}

void mexFunction( int nlhs, mxArray *plhs[],
		  int nrhs, const mxArray *prhs[] )
{
  double *x,*y;
  size_t mrows,ncols;

  /* Check for proper number of arguments. */
  if(nrhs!=1) {
    mexErrMsgIdAndTxt( "MATLAB:timestwo:invalidNumInputs",
	    "One input required.");
  } else if(nlhs>1) {
    mexErrMsgIdAndTxt( "MATLAB:timestwo:maxlhs",
	    "Too many output arguments.");
  }

  /* The input must be a noncomplex scalar double.*/
  mrows = mxGetM(prhs[0]);
  ncols = mxGetN(prhs[0]);
  if( !mxIsDouble(prhs[0]) || mxIsComplex(prhs[0]) ||
      !(mrows==1 && ncols==1) ) {
    mexErrMsgIdAndTxt(
    "MATLAB:timestwo:inputNotRealScalarDouble",
    "Input must be a noncomplex scalar double.");
  }

  /* Create matrix for the return argument. */
  plhs[0] = mxCreateDoubleMatrix((mwSize)mrows,
			   (mwSize)ncols, mxREAL);

  /* Assign pointers to each input and output. */
  x = mxGetPr(prhs[0]);
  y = mxGetPr(plhs[0]);

  /* Call the timestwo subroutine. */
  timestwo(y,x);
}
\end{lstlisting}

代码的第2-5行实现了乘以2的功能。代码的第7-42行实现了 \texttt{mexFunction} 。代码的第14-20行用来检查输入数据的格式，这些代码的主要作用是方便调试，暂时不管。代码的第23-24行获得了输入数据的维度，用于为输出数据指定内存空间大小。第33-34行调用了本文介绍的 \texttt{mxCreateDoubleMatrix} API。 并将返回地址赋给 \texttt{plhs[0]} 。

第33行至第41行是 \texttt{mexFunction} 的核心。通过 \texttt{mxCreateDoubleMatrix} 申请保存输出的内存空间，并把地址赋给 \texttt{plhs[0]} 这样matlab脚本就可以得到C函数的输出。 通过调用 \texttt{mxGetPr} 函数把 \texttt{plhs[0]} 的值赋给 \texttt{y} ，然后在C函数中为 \texttt{y} 指向的内存单元复制，这里 \texttt{y} 也是指针。 \texttt{mxGetPr} 函数实现了 \texttt{mxArray} 指针向 \texttt{double} 类型指针的转换。
\section{另一个例子}
\label{sec:orgheadline6}


再来一个例子，本例完成标量和矩阵相乘的功能。代码如下：

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=left}
\begin{lstlisting}
#include "mex.h"
void xtimesy(double x, double *y,
	     double *z, size_t m, size_t n)
{
  mwSize i,j,count=0;

  for (i=0; i<n; i++) {
    for (j=0; j<m; j++) {
      *(z+count) = x * *(y+count);
      count++;
    }
  }
}

/* the gateway function */
void mexFunction( int nlhs, mxArray *plhs[],
		  int nrhs, const mxArray *prhs[])
{
  double *y,*z;
  double  x;
  size_t mrows,ncols;

  /*  check for proper number of arguments */
  /* NOTE: You do not need an else statement when
     using mexErrMsgIdAndTxt within an if statement,
     because it will never get to the else statement
     if mexErrMsgIdAndTxt is executed.
     (mexErrMsgIdAndTxt breaks you out of the
    MEX-file) */
  if(nrhs!=2)
    mexErrMsgIdAndTxt(
	    "MATLAB:xtimesy:invalidNumInputs",
	    "Two inputs required.");
  if(nlhs!=1)
    mexErrMsgIdAndTxt(
	    "MATLAB:xtimesy:invalidNumOutputs",
	    "One output required.");

  /* check to make sure the first input argument is
     a scalar */
  if( !mxIsDouble(prhs[0]) ||
      mxIsComplex(prhs[0]) ||
      mxGetN(prhs[0])*mxGetM(prhs[0])!=1 ) {
    mexErrMsgIdAndTxt( "MATLAB:xtimesy:xNotScalar",
	    "Input x must be a scalar.");
  }

  /*  get the scalar input x */
  x = mxGetScalar(prhs[0]);

  /*  create a pointer to the input matrix y */
  y = mxGetPr(prhs[1]);

  /*  get the dimensions of the matrix input y */
  mrows = mxGetM(prhs[1]);
  ncols = mxGetN(prhs[1]);

  /*  set the output pointer to the output matrix */
  plhs[0] = mxCreateDoubleMatrix( (mwSize)mrows,
			    (mwSize)ncols, mxREAL);

  /*  create a C pointer to a copy of the
      output matrix */
  z = mxGetPr(plhs[0]);

  /*  call the C subroutine */
  xtimesy(x,y,z,mrows,ncols);

}
\end{lstlisting}

本例的第2-13行完成了标量乘以矩阵的c函数。在桥梁函数中，matlab传入的矩阵 \texttt{y} 体现为指向矩阵 \texttt{y} 的第一个元素的地址。这个通过第52行代码实现。
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
y = mxGetPr(prhs[1]);
\end{lstlisting}

第55行和第56行代码分别调用 \texttt{mxGetM} 和 \texttt{mxGetN} 获得传入矩阵 \texttt{y} 的行数和列数。第59行调用 \texttt{mxCreateDoulbeMatrix} 为输出分配内存空间，创建了行数为 \texttt{mrows} ,列数为 \texttt{ncols} 的实数矩阵空间。 第64行把这个是数据矩阵空间的地址通过 \texttt{mxGetPr} 赋给 \texttt{z} ，经过第64行， \texttt{plhs[0]} 指向内存单元就和 \texttt{z} 指向的内存单元相同。

最后需要注意的一点：在matlab中矩阵的索引是按 \textbf{列} 进行的，比如一个矩阵x=[ 1 2; 3 4]，则用一个索引变量遍历x结果为：x(1) = 1,x(2) = 3,x(3) =2, x(4) =4，也就是说矩阵的第二个元素是3不是2。用两个索引变量为：x(1,1) = 1, x(1,2) =2,x(2,1) =x3,x(2,2)=4。之所以交代这个的原因是在matlab中，传入的是指向矩阵第一个元素的指针，其加1指向的是矩阵的第二个元素，也就是矩阵的第二列第一个元素，不是矩阵的第一行第二列的那个元素。

\section{\texttt{mxCreateDoubleScalar}}
\label{sec:orgheadline7}


既然介绍了 \texttt{mxCreateDoulbeMatrix}  ，就顺带提一下另一个API \texttt{mxCreateDoubleScalar} 。这个API是 \texttt{mxCreateDoulbeMatrix} 的特殊形式，其创建指向一个double标量的指针，并初始化。其语法为：
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
pa = mxCreateDoubleScalar(value);
\end{lstlisting}
pa是个地址指向一个doulbe值，大小为 \texttt{value} 。

用 \texttt{mxCreateDoulbeMatrix} 完成就是：
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
pa = mxCreateDoubleMatrix(1, 1, mxREAL);
*mxGetPr(pa) = value;
\end{lstlisting}

显然，在桥梁变量里创建标量的时， \texttt{mxCreateDoubleScalar} 更方便。
\section{尾声}
\label{sec:orgheadline8}


本文通过简单介绍了 \texttt{mxCreateDoulbeMatrix} API，并通过两个例子阐述了其用法，还介绍了其特殊形式 \texttt{mxCreateDoubleScalar} 。 在两个例子中顺带介绍了 \texttt{mxGetM} \texttt{mxGetN} \texttt{mxGetPr} ，关于这后三个简单的API就不另开博文做专门介绍了。
\end{document}
